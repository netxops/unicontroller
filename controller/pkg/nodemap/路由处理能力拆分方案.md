# 路由处理能力拆分与通用项目设计方案

## 1. 概述

### 1.1 目标

将当前 `nodemap` 项目中的路由处理能力拆分出来，创建一个**通用的路由处理项目**，具备以下能力：

1. **3层路由查询**：支持IPv4/IPv6路由查询
2. **路径查询和计算**：支持从源到目标的路径计算
3. **多路径支持**：支持ECMP（等价多路径）
4. **路径跟踪系统**：完整的路径跟踪和管理能力
5. **通用性**：可以被防火墙策略自动化、网络运维、路径分析等多种场景使用

### 1.2 当前架构分析

#### 1.2.1 路由相关核心组件

当前 `nodemap` 中路由相关的核心组件：

| 组件 | 位置 | 功能 | 依赖关系 |
|------|------|------|---------|
| **路由表管理** | `node/node.go` | VRF路由表管理 | 依赖 `network.AddressTable` |
| **路由查询** | `node/node.go:IpRouteCheck` | 路由匹配和查询 | 独立，可拆分 |
| **路径计算** | `traverse.go:TraverseProcess` | 路径遍历和计算 | **耦合** `policy.Intent` |
| **源节点定位** | `nodemap.go:LocateNode` | 定位入口节点 | 独立，可拆分 |
| **连接器管理** | `cxmananger.go` | 端口连接关系 | 独立，可拆分 |
| **路由跟踪** | `route_tracer.go` | 路由决策跟踪 | 独立，可拆分 |

#### 1.2.2 与防火墙策略的耦合点

当前系统与防火墙策略的耦合：

1. **TraverseProcess 使用 policy.Intent**
   ```go
   type TraverseProcess struct {
       Intent *policy.Intent  // 策略意图（源网络、目标网络）
       // ...
   }
   ```

2. **TraverseNode 处理防火墙节点**
   ```go
   case api.FIREWALL:
       firewallProcessor := firewall.NewFirewallProcess(...)
       // 处理防火墙策略
   ```

3. **结果存储与防火墙相关**
   ```go
   type TraverseResultItem struct {
       StepProcess *processor.NodeProcessor  // 包含防火墙处理步骤
       CmdListList []interface{}              // 防火墙配置命令
   }
   ```

---

## 2. 通用路由处理项目设计

### 2.1 项目架构

```
pkg/routing/  (新的通用路由处理项目)
├── core/                    # 核心路由处理能力
│   ├── route_table.go      # 路由表管理
│   ├── route_query.go      # 路由查询
│   ├── path_calculator.go  # 路径计算
│   ├── path_tracker.go     # 路径跟踪系统
│   └── node_locator.go     # 节点定位
├── model/                   # 数据模型
│   ├── route.go            # 路由模型
│   ├── path.go             # 路径模型
│   ├── node.go             # 节点模型（抽象）
│   └── network.go          # 网络模型
├── graph/                   # 图结构（网络拓扑）
│   ├── topology.go         # 网络拓扑
│   ├── connector.go        # 连接器
│   └── node.go             # 图节点
├── adapter/                 # 适配器接口（可选）
│   └── route_adapter.go    # 路由数据适配器接口
├── query/                   # 查询接口
│   ├── route_query.go      # 路由查询接口
│   └── path_query.go       # 路径查询接口
└── multipath/               # 多路径支持
    ├── ecmp.go             # ECMP支持
    └── path_tracker.go     # 路径跟踪（多路径）
```

### 2.2 核心接口设计

#### 2.2.1 路由查询接口

```go
// RouteQuery 路由查询接口
type RouteQuery interface {
    // QueryRoute 查询路由
    QueryRoute(dst network.NetworkList, inPort, vrf string, ipFamily network.IPFamily) (*RouteResult, error)
    
    // QueryAllRoutes 查询所有匹配的路由（支持多路径）
    QueryAllRoutes(dst network.NetworkList, inPort, vrf string, ipFamily network.IPFamily) ([]*RouteResult, error)
}

// RouteResult 路由查询结果
type RouteResult struct {
    Matched      bool
    Routes       []*RouteEntry
    OutPorts     []string
    NextHops     []*NextHopInfo
    IsConnected  bool  // 是否为直连路由
    IsECMP       bool  // 是否为ECMP路由
}

// RouteEntry 路由条目
type RouteEntry struct {
    Network      *network.IPNet
    NextHops     []*NextHopInfo
    VRF          string
    Connected    bool
    DefaultGw    bool
}

// NextHopInfo 下一跳信息
type NextHopInfo struct {
    Interface    string
    NextHopIP    string
    Connected    bool
    Weight       int  // 路径权重（用于ECMP）
}
```

#### 2.2.2 路径查询接口

```go
// PathQuery 路径查询接口
type PathQuery interface {
    // QueryPath 查询单条路径
    QueryPath(src, dst network.NetworkList, options *PathQueryOptions) (*PathResult, error)
    
    // QueryAllPaths 查询所有路径（支持多路径）
    QueryAllPaths(src, dst network.NetworkList, options *PathQueryOptions) ([]*PathResult, error)
}

// PathQueryOptions 路径查询选项
type PathQueryOptions struct {
    VRF          string
    Gateway      string
    Area         string
    SourceNode   string
    MaxPaths     int  // 最大路径数
    EnableECMP   bool // 是否启用ECMP
    MaxDepth     int  // 最大路径深度
}

// PathResult 路径查询结果
type PathResult struct {
    PathID       string
    Success      bool
    Hops         []*PathHop
    TotalHops    int
    IsECMP       bool
    Error        error
    Metadata     map[string]interface{}
}

// PathHop 路径跳
type PathHop struct {
    Node         string
    InPort       string
    OutPort      string
    VRF          string
    NextHopIP    string
    IsConnected  bool
    IsECMP       bool
}
```

#### 2.2.3 网络拓扑接口

```go
// Topology 网络拓扑接口
type Topology interface {
    // AddNode 添加节点
    AddNode(node Node) error
    
    // GetNode 获取节点
    GetNode(nodeID string) (Node, error)
    
    // LocateSourceNode 定位源节点
    LocateSourceNode(src network.NetworkList, options *LocateOptions) (Node, Port, error)
    
    // GetConnector 获取连接器
    GetConnector(portID string) (Connector, error)
}

// Node 节点接口（抽象，不依赖具体设备类型）
type Node interface {
    ID() string
    Name() string
    Type() NodeType
    
    // 路由表管理
    GetRouteTable(vrf string, ipFamily network.IPFamily) (*RouteTable, error)
    SetRouteTable(vrf string, ipFamily network.IPFamily, table *RouteTable) error
    
    // 路由查询
    QueryRoute(dst network.NetworkList, inPort, vrf string, ipFamily network.IPFamily) (*RouteResult, error)
    
    // 端口管理
    GetPort(portID string) (Port, error)
    GetPortByName(name string) (Port, error)
    ListPorts() []Port
}

// Port 端口接口
type Port interface {
    ID() string
    Name() string
    VRF() string
    Node() Node
    IPAddresses(ipFamily network.IPFamily) []string
    ConnectorID() string
}

// Connector 连接器接口
type Connector interface {
    ID() string
    SelectNodeByIP(ip, vrf string) (Node, Port, error)
    SelectPortsByNetwork(net network.AbbrNet, vrf string) []Port
}
```

### 2.3 路径跟踪系统（多路径支持）

```go
// PathTracker 路径跟踪器
type PathTracker interface {
    // StartPath 开始跟踪一条新路径
    StartPath(pathID string, parentPathID string, isECMP bool) error
    
    // AddNodeToPath 将节点添加到路径
    AddNodeToPath(pathID string, nodeID string) error
    
    // CompletePath 完成路径
    CompletePath(pathID string, success bool, err error) error
    
    // GetPathState 获取路径状态
    GetPathState(pathID string) (PathState, error)
    
    // GetNodePaths 获取访问过节点的所有路径
    GetNodePaths(nodeID string) []string
    
    // MergeNodeResults 合并节点在不同路径上的结果
    MergeNodeResults(nodeID string) (interface{}, error)
    
    // GetStats 获取统计信息
    GetStats() *PathTrackerStats
}

// PathState 路径状态
type PathState int

const (
    PathStatePending PathState = iota
    PathStateRunning
    PathStateSuccess
    PathStateFailed
    PathStateMerged
)
```

---

## 3. 拆分方案

### 3.1 拆分策略

采用**渐进式拆分**策略：

1. **阶段1**：创建新的通用路由处理项目
2. **阶段2**：实现核心路由处理能力
3. **阶段3**：实现多路径支持
4. **阶段4**：nodemap集成新项目
5. **阶段5**：逐步迁移，保持兼容

### 3.2 代码拆分清单

#### 3.2.1 可完全拆分的组件

| 组件 | 当前位置 | 拆分后位置 | 说明 |
|------|---------|-----------|------|
| **路由表管理** | `node/node.go` | `routing/core/route_table.go` | 完全独立 |
| **路由查询** | `node/node.go:IpRouteCheck` | `routing/core/route_query.go` | 完全独立 |
| **连接器管理** | `cxmananger.go` | `routing/graph/connector.go` | 完全独立 |
| **源节点定位** | `nodemap.go:LocateNode` | `routing/core/node_locator.go` | 需要抽象化 |
| **路径跟踪** | `route_tracer.go` | `routing/multipath/path_tracker.go` | 完全独立 |

#### 3.2.2 需要抽象化的组件

| 组件 | 当前位置 | 拆分策略 |
|------|---------|---------|
| **TraverseProcess** | `traverse.go` | 抽象化，移除 `policy.Intent` 依赖 |
| **TraverseNode** | `traverse.go` | 抽象化，移除防火墙处理逻辑 |
| **Node接口** | `api/api.go` | 抽象化，移除防火墙特定方法 |

#### 3.2.3 保留在nodemap的组件

| 组件 | 说明 |
|------|------|
| **防火墙策略处理** | `node/device/firewall/` | 保留在nodemap |
| **策略匹配** | `policy.go` | 保留在nodemap |
| **设备适配器** | `adapter/fw/` | 保留在nodemap |

### 3.3 接口抽象化设计

#### 3.3.1 路径查询抽象化

**当前实现**（耦合policy.Intent）：
```go
type TraverseProcess struct {
    Intent *policy.Intent  // 策略意图
    // ...
}

func (tp *TraverseProcess) Traverse(ctx context.Context) {
    src := tp.Intent.Src()  // 从Intent获取源网络
    dst := tp.Intent.Dst()  // 从Intent获取目标网络
    // ...
}
```

**抽象化后**（通用接口）：
```go
type PathCalculator struct {
    Topology    Topology
    PathTracker PathTracker
    Options     *PathQueryOptions
    logger      *zap.Logger
}

type PathQueryOptions struct {
    Source      network.NetworkList  // 源网络（替代Intent.Src()）
    Destination network.NetworkList  // 目标网络（替代Intent.Dst()）
    VRF         string
    Gateway     string
    Area        string
    SourceNode  string
    MaxPaths    int
    EnableECMP  bool
}

func (pc *PathCalculator) CalculatePath(ctx context.Context) ([]*PathResult, error) {
    // 使用PathQueryOptions而不是policy.Intent
    // ...
}
```

#### 3.3.2 节点处理抽象化

**当前实现**（耦合防火墙）：
```go
func (tn *TraverseNode) MarkFunctionNode(...) {
    switch tn.Node.NodeType() {
    case api.FIREWALL:
        firewallProcessor := firewall.NewFirewallProcess(...)
        // 处理防火墙策略
    case api.LB:
        // 处理负载均衡
    }
}
```

**抽象化后**（使用回调函数）：
```go
type PathCalculator struct {
    // ...
    NodeProcessor NodeProcessor  // 节点处理器接口
}

type NodeProcessor interface {
    // ProcessNode 处理节点（由具体业务实现）
    ProcessNode(ctx context.Context, node Node, inPort Port, path *PathResult) (interface{}, error)
}

// 在nodemap中实现NodeProcessor
type FirewallNodeProcessor struct {
    // 实现防火墙特定的处理逻辑
}

func (fnp *FirewallNodeProcessor) ProcessNode(ctx context.Context, node Node, inPort Port, path *PathResult) (interface{}, error) {
    // 防火墙策略处理逻辑
}
```

---

## 4. 新项目结构设计

### 4.1 项目目录结构

```
pkg/routing/
├── README.md
├── go.mod
├── core/                          # 核心路由处理
│   ├── route_table.go            # 路由表管理
│   ├── route_query.go            # 路由查询
│   ├── path_calculator.go        # 路径计算器
│   ├── node_locator.go           # 节点定位
│   └── route_matcher.go          # 路由匹配算法
├── model/                         # 数据模型
│   ├── route.go                  # 路由模型
│   ├── path.go                   # 路径模型
│   ├── node.go                   # 节点模型（抽象）
│   ├── port.go                   # 端口模型
│   └── network.go                # 网络模型
├── graph/                         # 图结构（网络拓扑）
│   ├── topology.go               # 网络拓扑
│   ├── connector.go              # 连接器
│   ├── connector_manager.go      # 连接器管理
│   └── node.go                   # 图节点
├── multipath/                     # 多路径支持
│   ├── path_tracker.go           # 路径跟踪器
│   ├── ecmp.go                   # ECMP支持
│   ├── path_state.go             # 路径状态管理
│   └── result_merger.go          # 结果合并
├── query/                         # 查询接口
│   ├── route_query.go            # 路由查询接口
│   ├── path_query.go             # 路径查询接口
│   └── options.go                # 查询选项
├── adapter/                       # 适配器接口（可选）
│   └── route_adapter.go          # 路由数据适配器
├── tracer/                        # 路由跟踪（可选）
│   ├── route_tracer.go           # 路由跟踪器
│   └── events.go                 # 跟踪事件
└── example/                       # 使用示例
    ├── basic_query.go            # 基本路由查询示例
    ├── path_calculation.go       # 路径计算示例
    └── multipath_example.go     # 多路径示例
```

### 4.2 核心模块设计

#### 4.2.1 路由表管理模块

```go
// pkg/routing/core/route_table.go

package core

import (
    "github.com/netxops/utils/network"
)

// RouteTable 路由表（封装AddressTable）
type RouteTable struct {
    vrf       string
    ipFamily  network.IPFamily
    table     *network.AddressTable
}

// NewRouteTable 创建路由表
func NewRouteTable(vrf string, ipFamily network.IPFamily) *RouteTable {
    return &RouteTable{
        vrf:      vrf,
        ipFamily: ipFamily,
        table:    network.NewAddressTable(ipFamily),
    }
}

// AddRoute 添加路由
func (rt *RouteTable) AddRoute(net *network.IPNet, nextHop *NextHop) error {
    return rt.table.PushRoute(net, nextHop)
}

// QueryRoute 查询路由
func (rt *RouteTable) QueryRoute(dst network.NetworkList) (*RouteMatchResult, error) {
    rmr := rt.table.MatchNetList(dst, true, false)
    // 转换为RouteMatchResult
    // ...
}

// GetDefaultGateway 获取默认网关
func (rt *RouteTable) GetDefaultGateway() *NextHop {
    return rt.table.DefaultGw()
}
```

#### 4.2.2 路径计算器模块

```go
// pkg/routing/core/path_calculator.go

package core

import (
    "context"
    "github.com/netxops/utils/network"
)

// PathCalculator 路径计算器
type PathCalculator struct {
    topology    Topology
    pathTracker PathTracker
    options     *PathQueryOptions
    logger      *zap.Logger
}

// NewPathCalculator 创建路径计算器
func NewPathCalculator(topology Topology, options *PathQueryOptions) *PathCalculator {
    return &PathCalculator{
        topology:    topology,
        pathTracker: NewPathTracker(),
        options:     options,
    }
}

// CalculatePath 计算路径
func (pc *PathCalculator) CalculatePath(ctx context.Context) ([]*PathResult, error) {
    // 1. 定位源节点
    srcNode, srcPort, err := pc.topology.LocateSourceNode(
        pc.options.Source,
        &LocateOptions{
            VRF:     pc.options.VRF,
            Gateway: pc.options.Gateway,
            Area:    pc.options.Area,
            Node:    pc.options.SourceNode,
        })
    if err != nil {
        return nil, err
    }
    
    // 2. 创建初始路径
    pathID := pc.pathTracker.StartPath("", "", false)
    
    // 3. 开始路径计算
    return pc.calculatePathRecursive(ctx, srcNode, srcPort, pathID, pc.options.Destination)
}

// calculatePathRecursive 递归计算路径
func (pc *PathCalculator) calculatePathRecursive(
    ctx context.Context,
    node Node,
    inPort Port,
    pathID string,
    dst network.NetworkList) ([]*PathResult, error) {
    
    // 1. 检查路径状态
    if pc.pathTracker.CheckNodeVisited(pathID, node.ID()) {
        return nil, ErrPathLoop
    }
    
    // 2. 添加节点到路径
    pc.pathTracker.AddNodeToPath(pathID, node.ID())
    
    // 3. 查询路由
    routeResult, err := node.QueryRoute(dst, inPort.Name(), inPort.VRF(), pc.options.IPFamily)
    if err != nil {
        pc.pathTracker.CompletePath(pathID, false, err)
        return nil, err
    }
    
    // 4. 处理直连路由
    if routeResult.IsConnected {
        pc.pathTracker.CompletePath(pathID, true, nil)
        return []*PathResult{pc.buildPathResult(pathID, true)}, nil
    }
    
    // 5. 处理下一跳
    if len(routeResult.NextHops) == 0 {
        pc.pathTracker.CompletePath(pathID, false, ErrNoNextHop)
        return nil, ErrNoNextHop
    }
    
    // 6. 多路径处理
    if len(routeResult.NextHops) > 1 && pc.options.EnableECMP {
        return pc.handleECMP(ctx, node, inPort, pathID, routeResult.NextHops, dst)
    }
    
    // 7. 单路径处理
    return pc.handleSinglePath(ctx, node, inPort, pathID, routeResult.NextHops[0], dst)
}
```

#### 4.2.3 多路径支持模块

```go
// pkg/routing/multipath/path_tracker.go

package multipath

import (
    "sync"
    "time"
)

// PathTracker 路径跟踪器（完整实现）
type PathTracker struct {
    mu sync.RWMutex
    
    paths        map[string]*PathStateInfo
    nodePaths    map[string]map[string]bool
    pathNodes    map[string][]string
    pathResults  map[string]map[string]interface{}
    pathRelations map[string]*PathRelation
    stats        *PathTrackerStats
}

// PathStateInfo 路径状态信息
type PathStateInfo struct {
    PathID       string
    State        PathState
    ParentPathID string
    BranchIndex  int
    StartTime    time.Time
    EndTime      time.Time
    Error        error
    NodeCount    int
    IsECMP       bool
}

// PathRelation 路径关系
type PathRelation struct {
    ParentPathID string
    ChildPathIDs []string
    MergePathID  string
}

// PathTrackerStats 统计信息
type PathTrackerStats struct {
    TotalPaths    int
    SuccessPaths  int
    FailedPaths   int
    ECMPPaths     int
    MergedNodes   int
    MaxPathDepth  int
    AvgPathLength float64
}
```

---

## 5. nodemap集成方案

### 5.1 集成策略

nodemap作为**业务层**，使用通用的routing项目：

```
┌─────────────────────────────────────────────────────────┐
│              nodemap (业务层)                            │
│  - 防火墙策略自动化                                       │
│  - 策略匹配和生成                                         │
│  - 设备配置管理                                           │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ 使用
┌─────────────────────────────────────────────────────────┐
│              routing (通用路由处理层)                      │
│  - 路由查询                                               │
│  - 路径计算                                               │
│  - 多路径支持                                             │
└─────────────────────────────────────────────────────────┘
```

### 5.2 nodemap适配层

在nodemap中创建适配层，将routing项目与nodemap的业务逻辑连接：

```go
// pkg/nodemap/routing_adapter.go

package nodemap

import (
    "github.com/netxops/l2service/pkg/routing"
    "github.com/netxops/utils/policy"
)

// NodeMapPathCalculator nodemap路径计算器适配器
type NodeMapPathCalculator struct {
    calculator *routing.PathCalculator
    nodeMap    *NodeMap
}

// NewNodeMapPathCalculator 创建nodemap路径计算器
func NewNodeMapPathCalculator(nodeMap *NodeMap) *NodeMapPathCalculator {
    // 将NodeMap适配为routing.Topology
    topology := NewNodeMapTopologyAdapter(nodeMap)
    
    return &NodeMapPathCalculator{
        calculator: routing.NewPathCalculator(topology, nil),
        nodeMap:    nodeMap,
    }
}

// CalculatePathFromIntent 从策略意图计算路径
func (nmpc *NodeMapPathCalculator) CalculatePathFromIntent(
    ctx context.Context,
    intent *policy.Intent,
    vrf, gateway, area string) ([]*routing.PathResult, error) {
    
    // 将policy.Intent转换为routing.PathQueryOptions
    options := &routing.PathQueryOptions{
        Source:      intent.Src().NetworkList(intent.Src().Type()),
        Destination: intent.Dst().NetworkList(intent.Dst().Type()),
        VRF:         vrf,
        Gateway:     gateway,
        Area:        area,
        SourceNode:  intent.InputNode,
        EnableECMP:  true,  // 启用多路径
        MaxPaths:    100,
    }
    
    nmpc.calculator.SetOptions(options)
    
    // 计算路径
    return nmpc.calculator.CalculatePath(ctx)
}

// NodeMapTopologyAdapter 将NodeMap适配为routing.Topology
type NodeMapTopologyAdapter struct {
    nodeMap *NodeMap
}

func (nmta *NodeMapTopologyAdapter) LocateSourceNode(
    src network.NetworkList,
    options *routing.LocateOptions) (routing.Node, routing.Port, error) {
    
    // 调用nodemap的LocateNode
    ok, node, portName := nmta.nodeMap.LocateNode(
        &src, nil, options.Node, options.VRF, options.Gateway, options.Area)
    
    if !ok {
        return nil, nil, fmt.Errorf("无法定位源节点: %s", portName)
    }
    
    port := node.GetPortByNameOrAlias(portName)
    if port == nil {
        return nil, nil, fmt.Errorf("无法获取端口: %s", portName)
    }
    
    // 将nodemap的Node和Port适配为routing的Node和Port
    return NewNodeAdapter(node), NewPortAdapter(port), nil
}
```

### 5.3 修改TraverseProcess使用routing项目

```go
// pkg/nodemap/traverse.go

type TraverseProcess struct {
    graph.SimpleGraph
    Intent         *policy.Intent
    IPFamily       network.IPFamily
    NodeMap        *NodeMap
    Vrf            string
    Gateway        string
    Area           string
    TraverseOnly   bool
    FuncationNodes []api.Node
    Results        *TraverseResult
    logger         *zap.Logger
    Vertices       map[interface{}]graph.Vertex
    RouteTracer    *RouteTracer
    
    // ========== 新增：使用routing项目 ==========
    PathCalculator *routing.PathCalculator  // 使用通用路径计算器
}

func (tp *TraverseProcess) Traverse(ctx context.Context) {
    // 使用routing项目计算路径
    pathResults, err := tp.PathCalculator.CalculatePath(ctx)
    if err != nil {
        tp.Results.err = model.NewProcessErr(err.Error(), model.RouteQuery)
        return
    }
    
    // 处理路径结果，转换为nodemap的TraverseResult
    for _, pathResult := range pathResults {
        tp.processPathResult(ctx, pathResult)
    }
}

func (tp *TraverseProcess) processPathResult(ctx context.Context, pathResult *routing.PathResult) {
    // 遍历路径上的每个节点
    for _, hop := range pathResult.Hops {
        node := tp.NodeMap.GetNode(hop.Node)
        if node == nil {
            continue
        }
        
        // 如果是防火墙节点，处理策略
        if node.NodeType() == api.FIREWALL {
            tp.processFirewallNode(ctx, node, hop, pathResult)
        }
    }
}
```

---

## 6. 多路径升级方案

### 6.1 在routing项目中实现多路径

在通用的routing项目中直接实现多路径支持：

```go
// pkg/routing/core/path_calculator.go

func (pc *PathCalculator) handleECMP(
    ctx context.Context,
    node Node,
    inPort Port,
    parentPathID string,
    nextHops []*NextHopInfo,
    dst network.NetworkList) ([]*PathResult, error) {
    
    var allPaths []*PathResult
    
    // 为每个下一跳创建独立的路径分支
    for i, nextHop := range nextHops {
        // 创建新的路径ID
        branchPathID := pc.pathTracker.GeneratePathID(
            parentPathID, node.ID(), inPort.VRF(), inPort.Name(), nextHop.Interface)
        
        // 启动新路径跟踪
        pc.pathTracker.StartPath(branchPathID, parentPathID, true)
        
        // 查找下一跳节点
        connector := pc.topology.GetConnector(inPort.ConnectorID())
        nextNode, nextPort, err := connector.SelectNodeByIP(nextHop.NextHopIP, inPort.VRF())
        if err != nil {
            pc.pathTracker.CompletePath(branchPathID, false, err)
            continue
        }
        
        // 递归计算路径
        branchPaths, err := pc.calculatePathRecursive(
            ctx, nextNode, nextPort, branchPathID, dst)
        if err != nil {
            pc.pathTracker.CompletePath(branchPathID, false, err)
            continue
        }
        
        allPaths = append(allPaths, branchPaths...)
    }
    
    return allPaths, nil
}
```

### 6.2 路径跟踪系统集成

路径跟踪系统作为routing项目的核心组件：

```go
// pkg/routing/multipath/path_tracker.go

// PathTracker 完整的路径跟踪实现
// （参考路径跟踪系统设计.md）
```

---

## 7. 使用场景示例

### 7.1 防火墙策略自动化（nodemap）

```go
// 在nodemap中使用routing项目
calculator := NewNodeMapPathCalculator(nodeMap)
pathResults, err := calculator.CalculatePathFromIntent(ctx, intent, vrf, gateway, area)

// 处理路径结果，生成防火墙策略
for _, pathResult := range pathResults {
    for _, hop := range pathResult.Hops {
        node := nodeMap.GetNode(hop.Node)
        if node.NodeType() == api.FIREWALL {
            // 处理防火墙策略
            processFirewallPolicy(node, hop, intent)
        }
    }
}
```

### 7.2 网络运维工具

```go
// 独立的网络运维工具使用routing项目
import "github.com/netxops/l2service/pkg/routing"

// 创建拓扑
topology := routing.NewTopology()

// 添加节点和路由表
node := topology.AddNode(nodeConfig)
node.SetRouteTable("default", network.IPv4, routeTable)

// 查询路径
calculator := routing.NewPathCalculator(topology, &routing.PathQueryOptions{
    Source:      srcNetwork,
    Destination: dstNetwork,
    EnableECMP:  true,
})

paths, err := calculator.CalculatePath(ctx)
```

### 7.3 路径分析工具

```go
// 路径分析工具
analyzer := routing.NewPathAnalyzer(topology)

// 分析所有路径
analysis := analyzer.AnalyzePaths(src, dst, &routing.AnalysisOptions{
    EnableECMP:    true,
    MaxPaths:     100,
    IncludeStats: true,
})

fmt.Printf("总路径数: %d\n", analysis.TotalPaths)
fmt.Printf("ECMP路径: %d\n", analysis.ECMPPaths)
fmt.Printf("平均路径长度: %.2f\n", analysis.AvgPathLength)
```

---

## 8. 实施计划

### 阶段1：创建routing项目（1-2周）

1. 创建新项目结构
2. 定义核心接口
3. 实现基础数据模型

### 阶段2：实现核心功能（2-3周）

1. 实现路由表管理
2. 实现路由查询
3. 实现基础路径计算
4. 实现节点定位

### 阶段3：实现多路径支持（2-3周）

1. 实现路径跟踪系统
2. 实现ECMP支持
3. 实现结果合并机制

### 阶段4：nodemap集成（1-2周）

1. 创建适配层
2. 修改TraverseProcess使用routing项目
3. 保持向后兼容

### 阶段5：测试和优化（1-2周）

1. 单元测试
2. 集成测试
3. 性能优化

---

## 9. 优势分析

### 9.1 通用性

- ✅ **独立于业务逻辑**：routing项目不依赖防火墙策略
- ✅ **可复用**：可以被多种运维工具使用
- ✅ **清晰的接口**：提供清晰的API接口

### 9.2 可维护性

- ✅ **职责分离**：路由处理和业务逻辑分离
- ✅ **易于测试**：独立的项目更容易测试
- ✅ **易于扩展**：新功能更容易添加

### 9.3 多路径支持

- ✅ **原生支持**：在routing项目中直接支持多路径
- ✅ **路径跟踪**：完整的路径跟踪系统
- ✅ **结果合并**：自动合并相同节点的结果

---

## 10. 总结

### 10.1 核心要点

1. **拆分策略**：将路由处理能力拆分为独立的通用项目
2. **接口抽象**：通过接口抽象化，移除对防火墙策略的依赖
3. **多路径支持**：在通用项目中直接实现多路径支持
4. **渐进式迁移**：通过适配层逐步迁移，保持兼容性

### 10.2 关键设计

- **Topology接口**：抽象网络拓扑，不依赖具体实现
- **PathCalculator**：通用的路径计算器，不依赖业务逻辑
- **PathTracker**：完整的路径跟踪系统，支持多路径
- **适配层**：nodemap通过适配层使用routing项目

### 10.3 实施建议

1. **先实现routing项目**：确保核心功能完整
2. **再实现多路径**：在routing项目中直接支持多路径
3. **最后集成nodemap**：通过适配层集成，保持兼容

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX

