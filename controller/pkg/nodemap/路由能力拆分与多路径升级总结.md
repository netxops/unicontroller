# 路由能力拆分与多路径升级总结

## 1. 项目概述

### 1.1 目标

将当前 `nodemap` 项目中的路由处理能力拆分出来，创建一个**通用的路由处理项目**，同时实现**多路径支持**。

### 1.2 核心需求

1. **路由处理能力拆分**
   - 将3层路由查询能力独立出来
   - 将路径计算能力独立出来
   - 创建通用的路由处理项目

2. **多路径支持**
   - 支持ECMP（等价多路径）
   - 实现路径跟踪系统
   - 支持结果合并

3. **通用性**
   - 可以被防火墙策略自动化使用
   - 可以被其他运维项目使用
   - 提供清晰的API接口

---

## 2. 当前架构分析

### 2.1 路由相关组件

| 组件 | 位置 | 功能 | 可拆分性 |
|------|------|------|---------|
| **路由表管理** | `node/node.go` | VRF路由表管理 | ✅ 完全独立 |
| **路由查询** | `node/node.go:IpRouteCheck` | 路由匹配和查询 | ✅ 完全独立 |
| **路径计算** | `traverse.go:TraverseProcess` | 路径遍历和计算 | ⚠️ 需要抽象化 |
| **源节点定位** | `nodemap.go:LocateNode` | 定位入口节点 | ✅ 完全独立 |
| **连接器管理** | `cxmananger.go` | 端口连接关系 | ✅ 完全独立 |
| **路由跟踪** | `route_tracer.go` | 路由决策跟踪 | ✅ 完全独立 |

### 2.2 与防火墙策略的耦合

| 耦合点 | 位置 | 耦合程度 | 解决方案 |
|--------|------|---------|---------|
| **policy.Intent** | `traverse.go` | 强耦合 | 抽象为 `PathQueryOptions` |
| **防火墙节点处理** | `traverse.go:MarkFunctionNode` | 强耦合 | 使用回调函数或接口 |
| **结果存储** | `TraverseResult` | 中等耦合 | 抽象结果接口 |

### 2.3 多路径限制

| 限制点 | 位置 | 限制原因 |
|--------|------|---------|
| **路由查询限制** | `node/node.go:IpRouteCheck` | 缺乏路径跟踪能力 |
| **路径计算限制** | `traverse.go:RunL3Route` | 缺乏路径跟踪能力 |
| **结果合并缺失** | `TraverseResult` | 缺乏路径跟踪能力 |

**根本原因**：缺乏遍历过程中所有路径的跟踪处理能力

---

## 3. 解决方案设计

### 3.1 架构设计

```
┌─────────────────────────────────────────────────────────┐
│              nodemap (业务层)                            │
│  - 防火墙策略自动化                                       │
│  - 策略匹配和生成                                         │
│  - 设备配置管理                                           │
│  - 使用routing项目进行路径计算                            │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ 使用（通过适配层）
┌─────────────────────────────────────────────────────────┐
│              routing (通用路由处理层)                      │
│  - 路由查询                                               │
│  - 路径计算                                               │
│  - 多路径支持（ECMP）                                      │
│  - 路径跟踪系统                                           │
│  - 节点定位                                               │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ 使用
┌─────────────────────────────────────────────────────────┐
│              utils/network (基础网络库)                    │
│  - AddressTable                                           │
│  - NetworkList                                            │
│  - NextHop                                                │
└─────────────────────────────────────────────────────────┘
```

### 3.2 核心组件设计

#### 3.2.1 路由查询模块

```go
// pkg/routing/core/route_query.go

type RouteQuery interface {
    // QueryRoute 查询路由（单路径）
    QueryRoute(dst network.NetworkList, inPort, vrf string, ipFamily network.IPFamily) (*RouteResult, error)
    
    // QueryAllRoutes 查询所有路由（多路径）
    QueryAllRoutes(dst network.NetworkList, inPort, vrf string, ipFamily network.IPFamily) ([]*RouteResult, error)
}
```

#### 3.2.2 路径计算模块

```go
// pkg/routing/core/path_calculator.go

type PathCalculator struct {
    topology    Topology
    pathTracker PathTracker
    options     *PathQueryOptions
}

type PathQueryOptions struct {
    Source      network.NetworkList  // 替代 policy.Intent.Src()
    Destination network.NetworkList  // 替代 policy.Intent.Dst()
    VRF         string
    Gateway     string
    Area        string
    SourceNode  string
    EnableECMP  bool  // 启用多路径
    MaxPaths    int
}
```

#### 3.2.3 路径跟踪系统

```go
// pkg/routing/multipath/path_tracker.go

type PathTracker interface {
    // StartPath 开始跟踪一条新路径
    StartPath(pathID string, parentPathID string, isECMP bool) error
    
    // AddNodeToPath 将节点添加到路径
    AddNodeToPath(pathID string, nodeID string) error
    
    // CompletePath 完成路径
    CompletePath(pathID string, success bool, err error) error
    
    // GetNodePaths 获取访问过节点的所有路径
    GetNodePaths(nodeID string) []string
    
    // MergeNodeResults 合并节点在不同路径上的结果
    MergeNodeResults(nodeID string) (interface{}, error)
}
```

### 3.3 适配层设计

```go
// pkg/nodemap/routing_adapter.go

// NodeMapTopologyAdapter 将NodeMap适配为routing.Topology
type NodeMapTopologyAdapter struct {
    nodeMap *NodeMap
}

// NodeAdapter 将nodemap.Node适配为routing.Node
type NodeAdapter struct {
    node api.Node
}

// PortAdapter 将nodemap.Port适配为routing.Port
type PortAdapter struct {
    port api.Port
}

// ConnectorAdapter 将nodemap.Connector适配为routing.Connector
type ConnectorAdapter struct {
    connector api.Connector
}
```

---

## 4. 多路径支持实现

### 4.1 路径跟踪系统（核心）

**必须先实现路径跟踪系统，才能支持多路径**

路径跟踪系统包括：

1. **PathTracker**：路径跟踪器，管理所有路径的状态
2. **PathID**：路径唯一标识
3. **PathStateInfo**：路径状态信息
4. **NodePathResult**：节点在特定路径上的处理结果

详细设计请参考：`路径跟踪系统设计.md`

### 4.2 多路径处理流程

```
节点A (遇到ECMP)
  ├─> 路径1 (path_1) -> 节点B -> 节点D (成功)
  ├─> 路径2 (path_2) -> 节点C -> 节点D (成功)
  └─> 路径3 (path_3) -> 节点E -> 节点F (失败)

路径跟踪系统：
- 跟踪3条独立路径的状态
- 记录每条路径经过的节点
- 合并节点D的结果（路径1和路径2都经过节点D）
- 记录路径3的失败原因
```

### 4.3 关键实现点

1. **路径标识**
   ```go
   pathID := GeneratePathID(parentPathID, nodeID, vrf, inPort, outPort)
   ```

2. **路径状态管理**
   ```go
   pathTracker.StartPath(pathID, parentPathID, isECMP)
   pathTracker.AddNodeToPath(pathID, nodeID)
   pathTracker.CompletePath(pathID, success, err)
   ```

3. **结果合并**
   ```go
   mergedResult := pathTracker.MergeNodeResults(nodeID)
   ```

---

## 5. 实施计划

### 阶段0：路径跟踪系统（必须先实现）

**时间**：2-3周

**任务**：
1. 实现 `PathTracker` 核心组件
2. 实现路径状态管理
3. 实现节点路径映射
4. 实现结果合并机制

**产出**：
- `pkg/routing/multipath/path_tracker.go`
- 路径跟踪系统测试

### 阶段1：创建routing项目

**时间**：1-2周

**任务**：
1. 创建项目结构
2. 定义核心接口
3. 实现基础数据模型

**产出**：
- `pkg/routing/` 项目结构
- 核心接口定义

### 阶段2：实现核心功能

**时间**：2-3周

**任务**：
1. 实现路由表管理
2. 实现路由查询
3. 实现基础路径计算
4. 实现节点定位

**产出**：
- `pkg/routing/core/` 核心功能实现
- 基础功能测试

### 阶段3：实现多路径支持

**时间**：2-3周

**任务**：
1. 集成路径跟踪系统
2. 实现ECMP支持
3. 实现结果合并机制
4. 实现路径选择策略

**产出**：
- `pkg/routing/multipath/` 多路径支持
- 多路径功能测试

### 阶段4：nodemap集成

**时间**：1-2周

**任务**：
1. 创建适配层
2. 修改TraverseProcess使用routing项目
3. 保持向后兼容

**产出**：
- `pkg/nodemap/routing_adapter.go`
- 集成测试

### 阶段5：优化和完善

**时间**：1-2周

**任务**：
1. 性能优化
2. 功能完善
3. 文档完善

**产出**：
- 性能优化报告
- 完整文档

---

## 6. 关键设计决策

### 6.1 接口抽象化

**决策**：通过接口抽象化，移除对 `policy.Intent` 的依赖

**实现**：
- `PathQueryOptions` 替代 `policy.Intent`
- `NodeProcessor` 接口替代直接处理防火墙节点

### 6.2 适配层设计

**决策**：通过适配层连接nodemap和routing项目

**实现**：
- `NodeMapTopologyAdapter`：将NodeMap适配为Topology
- `NodeAdapter`、`PortAdapter`、`ConnectorAdapter`：适配具体类型

### 6.3 多路径支持

**决策**：在routing项目中直接实现多路径支持

**实现**：
- 路径跟踪系统作为核心组件
- ECMP支持作为标准功能
- 结果合并机制自动处理

---

## 7. 使用场景

### 7.1 防火墙策略自动化（nodemap）

```go
// nodemap使用routing项目
calculator := NewNodeMapPathCalculator(nodeMap)
paths, err := calculator.CalculatePathFromIntent(ctx, intent, vrf, gateway, area)

// 处理路径，生成防火墙策略
for _, path := range paths {
    processFirewallPolicy(path, intent)
}
```

### 7.2 网络运维工具

```go
// 独立的网络运维工具使用routing项目
topology := routing.NewTopology()
calculator := routing.NewPathCalculator(topology, options)
paths, err := calculator.CalculatePath(ctx)

// 分析路径
for _, path := range paths {
    analyzePath(path)
}
```

### 7.3 路径分析工具

```go
// 路径分析工具
analyzer := routing.NewPathAnalyzer(topology)
analysis := analyzer.AnalyzePaths(src, dst, options)

fmt.Printf("总路径数: %d\n", analysis.TotalPaths)
fmt.Printf("ECMP路径: %d\n", analysis.ECMPPaths)
```

---

## 8. 优势分析

### 8.1 通用性

- ✅ **独立于业务逻辑**：routing项目不依赖防火墙策略
- ✅ **可复用**：可以被多种运维工具使用
- ✅ **清晰的接口**：提供清晰的API接口

### 8.2 可维护性

- ✅ **职责分离**：路由处理和业务逻辑分离
- ✅ **易于测试**：独立的项目更容易测试
- ✅ **易于扩展**：新功能更容易添加

### 8.3 多路径支持

- ✅ **原生支持**：在routing项目中直接支持多路径
- ✅ **路径跟踪**：完整的路径跟踪系统
- ✅ **结果合并**：自动合并相同节点的结果

### 8.4 兼容性

- ✅ **向后兼容**：nodemap通过适配层使用，保持兼容
- ✅ **渐进式迁移**：可以逐步迁移，不影响现有功能

---

## 9. 风险与挑战

### 9.1 技术风险

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| **接口设计不当** | 高 | 充分设计，多轮评审 |
| **性能问题** | 中 | 性能测试，优化算法 |
| **兼容性问题** | 中 | 适配层设计，充分测试 |

### 9.2 实施风险

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| **时间超期** | 中 | 分阶段实施，优先级管理 |
| **功能缺失** | 中 | 详细需求分析，充分测试 |
| **集成问题** | 中 | 适配层设计，充分测试 |

---

## 10. 总结

### 10.1 核心要点

1. **拆分策略**：将路由处理能力拆分为独立的通用项目
2. **接口抽象**：通过接口抽象化，移除对防火墙策略的依赖
3. **路径跟踪系统**：必须先实现路径跟踪系统，才能支持多路径
4. **多路径支持**：在通用项目中直接实现多路径支持
5. **适配层设计**：nodemap通过适配层使用routing项目

### 10.2 关键设计

- **Topology接口**：抽象网络拓扑，不依赖具体实现
- **PathCalculator**：通用的路径计算器，不依赖业务逻辑
- **PathTracker**：完整的路径跟踪系统，支持多路径
- **适配层**：nodemap通过适配层使用routing项目

### 10.3 实施建议

1. **先实现路径跟踪系统**：这是支持多路径的基础
2. **再实现routing项目**：确保核心功能完整
3. **最后集成nodemap**：通过适配层集成，保持兼容

### 10.4 相关文档

1. **路由处理能力拆分方案**：`路由处理能力拆分方案.md`
2. **路由项目架构设计**：`路由项目架构设计.md`
3. **路径跟踪系统设计**：`路径跟踪系统设计.md`
4. **多路径支持方案**：`多路径支持方案.md`
5. **路由与路径计算深度分析**：`路由与路径计算深度分析.md`

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX

