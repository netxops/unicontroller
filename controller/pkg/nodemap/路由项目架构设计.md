# 通用路由处理项目架构设计

## 1. 架构对比

### 1.1 当前架构（nodemap）

```
┌─────────────────────────────────────────────────────────┐
│                    nodemap (混合架构)                      │
│                                                           │
│  ┌─────────────────────────────────────────────────┐   │
│  │  防火墙策略自动化 (业务逻辑)                      │   │
│  │  - 策略匹配和生成                                  │   │
│  │  - 设备配置管理                                    │   │
│  └─────────────────────────────────────────────────┘   │
│                          │                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │  路由处理能力 (核心能力)                           │   │
│  │  - 路由查询                                        │   │
│  │  - 路径计算                                        │   │
│  │  - 节点定位                                        │   │
│  └─────────────────────────────────────────────────┘   │
│                                                           │
│  问题：                                                  │
│  - 路由处理与业务逻辑耦合                                │
│  - 无法被其他项目复用                                    │
│  - 不支持多路径                                          │
└─────────────────────────────────────────────────────────┘
```

### 1.2 拆分后架构

```
┌─────────────────────────────────────────────────────────┐
│              nodemap (业务层)                            │
│  - 防火墙策略自动化                                       │
│  - 策略匹配和生成                                         │
│  - 设备配置管理                                           │
│  - 使用routing项目进行路径计算                            │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ 使用
┌─────────────────────────────────────────────────────────┐
│              routing (通用路由处理层)                      │
│  - 路由查询                                               │
│  - 路径计算                                               │
│  - 多路径支持（ECMP）                                      │
│  - 路径跟踪系统                                           │
│  - 节点定位                                               │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ 使用
┌─────────────────────────────────────────────────────────┐
│              utils/network (基础网络库)                    │
│  - AddressTable                                           │
│  - NetworkList                                            │
│  - NextHop                                                │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 项目结构设计

### 2.1 routing项目结构

```
pkg/routing/
├── README.md
├── go.mod
├── core/                          # 核心路由处理
│   ├── route_table.go            # 路由表管理
│   ├── route_query.go            # 路由查询
│   ├── path_calculator.go        # 路径计算器
│   ├── node_locator.go           # 节点定位
│   └── route_matcher.go          # 路由匹配算法
├── model/                         # 数据模型
│   ├── route.go                  # 路由模型
│   ├── path.go                   # 路径模型
│   ├── node.go                   # 节点模型（抽象）
│   ├── port.go                   # 端口模型
│   ├── connector.go              # 连接器模型
│   └── network.go                # 网络模型
├── graph/                         # 图结构（网络拓扑）
│   ├── topology.go               # 网络拓扑
│   ├── connector.go              # 连接器
│   ├── connector_manager.go     # 连接器管理
│   └── node.go                   # 图节点
├── multipath/                     # 多路径支持
│   ├── path_tracker.go           # 路径跟踪器
│   ├── ecmp.go                   # ECMP支持
│   ├── path_state.go             # 路径状态管理
│   └── result_merger.go          # 结果合并
├── query/                         # 查询接口
│   ├── route_query.go            # 路由查询接口
│   ├── path_query.go             # 路径查询接口
│   └── options.go                # 查询选项
├── tracer/                        # 路由跟踪（可选）
│   ├── route_tracer.go           # 路由跟踪器
│   └── events.go                 # 跟踪事件
└── example/                       # 使用示例
    ├── basic_query.go            # 基本路由查询示例
    ├── path_calculation.go       # 路径计算示例
    └── multipath_example.go     # 多路径示例
```

### 2.2 核心模块设计

#### 2.2.1 路由查询模块

```go
// pkg/routing/core/route_query.go

package core

import (
    "github.com/netxops/utils/network"
)

// RouteQuery 路由查询器
type RouteQuery struct {
    routeTable *RouteTable
}

// QueryRoute 查询路由（单路径）
func (rq *RouteQuery) QueryRoute(
    dst network.NetworkList,
    inPort, vrf string,
    ipFamily network.IPFamily) (*RouteResult, error) {
    
    // 1. 在路由表中匹配目标网络
    rmr := rq.routeTable.table.MatchNetList(dst, true, false)
    
    // 2. 检查是否完全匹配
    if rmr.Unmatch != nil && rmr.Unmatch.Len() > 0 {
        return nil, ErrNoRoute
    }
    
    // 3. 构建路由结果
    match, _ := rmr.Table()
    outInterfaces := match.Column("interface").List().Distinct()
    
    // 4. 检查输入端口（避免环路）
    var outPorts []string
    for _, p := range outInterfaces {
        if p.(string) == inPort {
            return nil, ErrRouteLoop
        }
        outPorts = append(outPorts, p.(string))
    }
    
    // 5. 提取下一跳信息
    var nextHops []*NextHopInfo
    for it := match.Iterator(); it.HasNext(); {
        _, hopMap := it.Next()
        nextHops = append(nextHops, &NextHopInfo{
            Interface: hopMap["interface"].(string),
            NextHopIP: hopMap["ip"].(string),
            Connected: hopMap["connected"].(bool),
        })
    }
    
    return &RouteResult{
        Matched:     true,
        OutPorts:    outPorts,
        NextHops:    nextHops,
        IsConnected: len(nextHops) > 0 && nextHops[0].Connected,
        IsECMP:      len(nextHops) > 1,
    }, nil
}

// QueryAllRoutes 查询所有路由（多路径）
func (rq *RouteQuery) QueryAllRoutes(
    dst network.NetworkList,
    inPort, vrf string,
    ipFamily network.IPFamily) ([]*RouteResult, error) {
    
    // 与QueryRoute类似，但返回所有可能的路径
    // 支持ECMP
    // ...
}
```

#### 2.2.2 路径计算器模块

```go
// pkg/routing/core/path_calculator.go

package core

import (
    "context"
    "github.com/netxops/utils/network"
)

// PathCalculator 路径计算器
type PathCalculator struct {
    topology    Topology
    pathTracker PathTracker
    options     *PathQueryOptions
    logger      *zap.Logger
}

// PathQueryOptions 路径查询选项
type PathQueryOptions struct {
    Source      network.NetworkList
    Destination network.NetworkList
    VRF         string
    Gateway     string
    Area        string
    SourceNode  string
    IPFamily    network.IPFamily
    MaxPaths    int
    EnableECMP  bool
    MaxDepth    int
}

// CalculatePath 计算路径
func (pc *PathCalculator) CalculatePath(ctx context.Context) ([]*PathResult, error) {
    // 1. 定位源节点
    srcNode, srcPort, err := pc.topology.LocateSourceNode(
        pc.options.Source,
        &LocateOptions{
            VRF:     pc.options.VRF,
            Gateway: pc.options.Gateway,
            Area:    pc.options.Area,
            Node:    pc.options.SourceNode,
        })
    if err != nil {
        return nil, err
    }
    
    // 2. 创建初始路径
    pathID := pc.pathTracker.GeneratePathID("", srcNode.ID(), srcPort.VRF(), srcPort.Name(), "")
    pc.pathTracker.StartPath(pathID, "", false)
    
    // 3. 开始路径计算
    return pc.calculatePathRecursive(ctx, srcNode, srcPort, pathID, pc.options.Destination)
}

// calculatePathRecursive 递归计算路径
func (pc *PathCalculator) calculatePathRecursive(
    ctx context.Context,
    node Node,
    inPort Port,
    pathID string,
    dst network.NetworkList) ([]*PathResult, error) {
    
    // 1. 检查路径状态（环路检测）
    if pc.pathTracker.CheckNodeVisited(pathID, node.ID()) {
        return nil, ErrPathLoop
    }
    
    // 2. 检查最大深度
    if pc.options.MaxDepth > 0 {
        depth := pc.pathTracker.GetPathDepth(pathID)
        if depth >= pc.options.MaxDepth {
            return nil, ErrMaxDepthExceeded
        }
    }
    
    // 3. 添加节点到路径
    pc.pathTracker.AddNodeToPath(pathID, node.ID())
    
    // 4. 查询路由
    routeResult, err := node.QueryRoute(dst, inPort.Name(), inPort.VRF(), pc.options.IPFamily)
    if err != nil {
        pc.pathTracker.CompletePath(pathID, false, err)
        return nil, err
    }
    
    // 5. 处理直连路由
    if routeResult.IsConnected {
        pc.pathTracker.CompletePath(pathID, true, nil)
        return []*PathResult{pc.buildPathResult(pathID, true)}, nil
    }
    
    // 6. 处理下一跳
    if len(routeResult.NextHops) == 0 {
        pc.pathTracker.CompletePath(pathID, false, ErrNoNextHop)
        return nil, ErrNoNextHop
    }
    
    // 7. 多路径处理
    if len(routeResult.NextHops) > 1 && pc.options.EnableECMP {
        return pc.handleECMP(ctx, node, inPort, pathID, routeResult.NextHops, dst)
    }
    
    // 8. 单路径处理
    return pc.handleSinglePath(ctx, node, inPort, pathID, routeResult.NextHops[0], dst)
}

// handleECMP 处理ECMP（多路径）
func (pc *PathCalculator) handleECMP(
    ctx context.Context,
    node Node,
    inPort Port,
    parentPathID string,
    nextHops []*NextHopInfo,
    dst network.NetworkList) ([]*PathResult, error) {
    
    var allPaths []*PathResult
    
    // 检查路径数量限制
    if pc.options.MaxPaths > 0 {
        stats := pc.pathTracker.GetStats()
        if stats.TotalPaths >= pc.options.MaxPaths {
            return nil, ErrMaxPathsExceeded
        }
    }
    
    // 为每个下一跳创建独立的路径分支
    for i, nextHop := range nextHops {
        // 创建新的路径ID
        branchPathID := pc.pathTracker.GeneratePathID(
            parentPathID, node.ID(), inPort.VRF(), inPort.Name(), nextHop.Interface)
        
        // 启动新路径跟踪
        pc.pathTracker.StartPath(branchPathID, parentPathID, true)
        
        // 查找下一跳节点
        connector := pc.topology.GetConnector(inPort.ConnectorID())
        nextNode, nextPort, err := connector.SelectNodeByIP(nextHop.NextHopIP, inPort.VRF())
        if err != nil {
            pc.pathTracker.CompletePath(branchPathID, false, err)
            continue
        }
        
        // 递归计算路径
        branchPaths, err := pc.calculatePathRecursive(
            ctx, nextNode, nextPort, branchPathID, dst)
        if err != nil {
            pc.pathTracker.CompletePath(branchPathID, false, err)
            continue
        }
        
        allPaths = append(allPaths, branchPaths...)
    }
    
    return allPaths, nil
}

// handleSinglePath 处理单路径
func (pc *PathCalculator) handleSinglePath(
    ctx context.Context,
    node Node,
    inPort Port,
    pathID string,
    nextHop *NextHopInfo,
    dst network.NetworkList) ([]*PathResult, error) {
    
    // 查找下一跳节点
    connector := pc.topology.GetConnector(inPort.ConnectorID())
    nextNode, nextPort, err := connector.SelectNodeByIP(nextHop.NextHopIP, inPort.VRF())
    if err != nil {
        pc.pathTracker.CompletePath(pathID, false, err)
        return nil, err
    }
    
    // 递归计算路径
    return pc.calculatePathRecursive(ctx, nextNode, nextPort, pathID, dst)
}
```

#### 2.2.3 拓扑接口设计

```go
// pkg/routing/graph/topology.go

package graph

import (
    "github.com/netxops/utils/network"
)

// Topology 网络拓扑接口
type Topology interface {
    // Node管理
    AddNode(node Node) error
    GetNode(nodeID string) (Node, error)
    ListNodes() []Node
    
    // 端口管理
    GetPort(portID string) (Port, error)
    ListPorts() []Port
    
    // 连接器管理
    GetConnector(connectorID string) (Connector, error)
    GetConnectorByNetwork(net network.AbbrNet, vrf string) (Connector, error)
    GetConnectorByIP(ip, vrf string) (Connector, error)
    
    // 节点定位
    LocateSourceNode(src network.NetworkList, options *LocateOptions) (Node, Port, error)
    
    // 区域和Stub管理
    GetPortsByArea(area string, ipFamily network.IPFamily) []Port
    IsOutsidePort(nodeID, portID string, ipFamily network.IPFamily) (bool, string)
    IsStubPort(nodeID, portID string, ipFamily network.IPFamily) bool
}

// LocateOptions 定位选项
type LocateOptions struct {
    VRF     string
    Gateway string
    Area    string
    Node    string
}
```

---

## 3. nodemap适配层设计

### 3.1 适配层架构

```
┌─────────────────────────────────────────────────────────┐
│              nodemap (业务层)                            │
│                                                           │
│  ┌─────────────────────────────────────────────────┐   │
│  │  TraverseProcess (使用routing项目)                │   │
│  │  - 调用routing.PathCalculator                    │   │
│  │  - 处理路径结果                                  │   │
│  │  - 生成防火墙策略                                │   │
│  └─────────────────────────────────────────────────┘   │
│                          │                               │
│  ┌─────────────────────────────────────────────────┐   │
│  │  Adapter Layer (适配层)                          │   │
│  │  - NodeMapTopologyAdapter                        │   │
│  │  - NodeAdapter                                   │   │
│  │  - PortAdapter                                   │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          ▲
                          │ 使用
┌─────────────────────────────────────────────────────────┐
│              routing (通用路由处理层)                      │
│  - PathCalculator                                        │
│  - Topology                                              │
│  - PathTracker                                           │
└─────────────────────────────────────────────────────────┘
```

### 3.2 适配器实现

```go
// pkg/nodemap/routing_adapter.go

package nodemap

import (
    "github.com/netxops/l2service/pkg/routing"
    "github.com/netxops/utils/network"
    "github.com/netxops/utils/policy"
)

// NodeMapTopologyAdapter 将NodeMap适配为routing.Topology
type NodeMapTopologyAdapter struct {
    nodeMap *NodeMap
}

var _ routing.Topology = (*NodeMapTopologyAdapter)(nil)

func NewNodeMapTopologyAdapter(nodeMap *NodeMap) *NodeMapTopologyAdapter {
    return &NodeMapTopologyAdapter{nodeMap: nodeMap}
}

func (nmta *NodeMapTopologyAdapter) LocateSourceNode(
    src network.NetworkList,
    options *routing.LocateOptions) (routing.Node, routing.Port, error) {
    
    // 调用nodemap的LocateNode
    ok, node, portName := nmta.nodeMap.LocateNode(
        &src, nil, options.Node, options.VRF, options.Gateway, options.Area)
    
    if !ok {
        return nil, nil, fmt.Errorf("无法定位源节点: %s", portName)
    }
    
    port := node.GetPortByNameOrAlias(portName)
    if port == nil {
        return nil, nil, fmt.Errorf("无法获取端口: %s", portName)
    }
    
    return NewNodeAdapter(node), NewPortAdapter(port), nil
}

func (nmta *NodeMapTopologyAdapter) GetConnector(connectorID string) (routing.Connector, error) {
    connector := nmta.nodeMap.CxMananger.GetConnectorByID(connectorID)
    if connector == nil {
        return nil, fmt.Errorf("连接器不存在: %s", connectorID)
    }
    return NewConnectorAdapter(connector), nil
}

// NodeAdapter 将nodemap.Node适配为routing.Node
type NodeAdapter struct {
    node api.Node
}

var _ routing.Node = (*NodeAdapter)(nil)

func NewNodeAdapter(node api.Node) *NodeAdapter {
    return &NodeAdapter{node: node}
}

func (na *NodeAdapter) ID() string {
    return na.node.ID()
}

func (na *NodeAdapter) Name() string {
    return na.node.Name()
}

func (na *NodeAdapter) QueryRoute(
    dst network.NetworkList,
    inPort, vrf string,
    ipFamily network.IPFamily) (*routing.RouteResult, error) {
    
    // 调用nodemap的IpRouteCheck
    ok, hopTable, outPorts, err := na.node.IpRouteCheck(dst, inPort, vrf, ipFamily)
    if err != nil {
        return nil, err
    }
    if !ok {
        return nil, routing.ErrNoRoute
    }
    
    // 转换为routing.RouteResult
    return convertToRouteResult(hopTable, outPorts), nil
}

func (na *NodeAdapter) GetRouteTable(vrf string, ipFamily network.IPFamily) (*routing.RouteTable, error) {
    var table *network.AddressTable
    if ipFamily == network.IPv4 {
        table = na.node.Ipv4RouteTable(vrf)
    } else {
        table = na.node.Ipv6RouteTable(vrf)
    }
    
    if table == nil {
        return nil, fmt.Errorf("路由表不存在: vrf=%s, ipFamily=%s", vrf, ipFamily)
    }
    
    return routing.NewRouteTableFromAddressTable(vrf, ipFamily, table), nil
}

// PortAdapter 将nodemap.Port适配为routing.Port
type PortAdapter struct {
    port api.Port
}

var _ routing.Port = (*PortAdapter)(nil)

func NewPortAdapter(port api.Port) *PortAdapter {
    return &PortAdapter{port: port}
}

func (pa *PortAdapter) ID() string {
    return pa.port.ID()
}

func (pa *PortAdapter) Name() string {
    return pa.port.Name()
}

func (pa *PortAdapter) VRF() string {
    return pa.port.Vrf()
}

func (pa *PortAdapter) Node() routing.Node {
    return NewNodeAdapter(pa.port.Node())
}

func (pa *PortAdapter) IPAddresses(ipFamily network.IPFamily) []string {
    return pa.port.GetIpList()[ipFamily]
}

func (pa *PortAdapter) ConnectorID() string {
    return pa.port.ConnectorID()
}

// ConnectorAdapter 将nodemap.Connector适配为routing.Connector
type ConnectorAdapter struct {
    connector api.Connector
}

var _ routing.Connector = (*ConnectorAdapter)(nil)

func NewConnectorAdapter(connector api.Connector) *ConnectorAdapter {
    return &ConnectorAdapter{connector: connector}
}

func (ca *ConnectorAdapter) ID() string {
    return ca.connector.ID()
}

func (ca *ConnectorAdapter) SelectNodeByIP(ip, vrf string) (routing.Node, routing.Port, error) {
    node, port := ca.connector.SelectNodeByIp(ip, vrf)
    if node == nil {
        return nil, nil, fmt.Errorf("未找到节点: ip=%s, vrf=%s", ip, vrf)
    }
    return NewNodeAdapter(node), NewPortAdapter(port), nil
}
```

### 3.3 修改TraverseProcess

```go
// pkg/nodemap/traverse.go

type TraverseProcess struct {
    graph.SimpleGraph
    Intent         *policy.Intent
    IPFamily       network.IPFamily
    NodeMap        *NodeMap
    Vrf            string
    Gateway        string
    Area           string
    TraverseOnly   bool
    FuncationNodes []api.Node
    Results        *TraverseResult
    logger         *zap.Logger
    Vertices       map[interface{}]graph.Vertex
    RouteTracer    *RouteTracer
    
    // ========== 新增：使用routing项目 ==========
    pathCalculator *routing.PathCalculator
}

func (tp *TraverseProcess) Traverse(ctx context.Context) {
    // 1. 创建适配层
    topologyAdapter := NewNodeMapTopologyAdapter(tp.NodeMap)
    
    // 2. 创建路径查询选项
    options := &routing.PathQueryOptions{
        Source:      tp.Intent.Src().NetworkList(tp.IPFamily),
        Destination: tp.Intent.Dst().NetworkList(tp.IPFamily),
        VRF:         tp.Vrf,
        Gateway:     tp.Gateway,
        Area:        tp.Area,
        SourceNode:  tp.Intent.InputNode,
        IPFamily:    tp.IPFamily,
        EnableECMP:  true,  // 启用多路径
        MaxPaths:    100,
    }
    
    // 3. 创建路径计算器
    tp.pathCalculator = routing.NewPathCalculator(topologyAdapter, options)
    
    // 4. 计算路径
    pathResults, err := tp.pathCalculator.CalculatePath(ctx)
    if err != nil {
        tp.Results.err = model.NewProcessErr(err.Error(), model.RouteQuery)
        return
    }
    
    // 5. 处理路径结果
    for _, pathResult := range pathResults {
        tp.processPathResult(ctx, pathResult)
    }
}

func (tp *TraverseProcess) processPathResult(ctx context.Context, pathResult *routing.PathResult) {
    // 遍历路径上的每个节点
    for i, hop := range pathResult.Hops {
        node := tp.NodeMap.GetNode(hop.Node)
        if node == nil {
            continue
        }
        
        // 获取入端口和出端口
        inPort := node.GetPortByNameOrAlias(hop.InPort)
        outPort := node.GetPortByNameOrAlias(hop.OutPort)
        
        // 如果是防火墙节点，处理策略
        if node.NodeType() == api.FIREWALL {
            tp.processFirewallNode(ctx, node, inPort, outPort, pathResult, i)
        }
    }
}

func (tp *TraverseProcess) processFirewallNode(
    ctx context.Context,
    node api.Node,
    inPort, outPort api.Port,
    pathResult *routing.PathResult,
    hopIndex int) {
    
    // 创建TraverseNode（用于防火墙处理）
    tn := NewTraverseNode(
        tp.NodeMap, node, tp.Intent.Copy().(*policy.Intent),
        inPort.Vrf(), inPort, tp.IPFamily,
        pathResult.PathID, tp, tp.TraverseOnly)
    
    // 处理防火墙策略
    tn.MarkFunctionNode(tp.TraverseOnly, ctx)
}
```

---

## 4. 多路径支持实现

### 4.1 路径跟踪系统（在routing项目中）

路径跟踪系统作为routing项目的核心组件，完整实现多路径支持：

```go
// pkg/routing/multipath/path_tracker.go

package multipath

// PathTracker 路径跟踪器（完整实现）
// （参考路径跟踪系统设计.md中的完整实现）
```

### 4.2 ECMP支持

```go
// pkg/routing/multipath/ecmp.go

package multipath

// ECMPHandler ECMP处理器
type ECMPHandler struct {
    pathTracker PathTracker
    options     *ECMPOptions
}

// ECMPOptions ECMP选项
type ECMPOptions struct {
    MaxPaths        int
    PathSelection   string  // all, first, random, round-robin
    LoadBalance     bool    // 是否启用负载均衡
    WeightBased     bool    // 是否基于权重选择
}

// HandleECMP 处理ECMP
func (eh *ECMPHandler) HandleECMP(
    nextHops []*NextHopInfo,
    handler func(nextHop *NextHopInfo) ([]*PathResult, error)) ([]*PathResult, error) {
    
    var allPaths []*PathResult
    
    // 根据选择策略处理
    switch eh.options.PathSelection {
    case "all":
        // 处理所有路径
        for _, nextHop := range nextHops {
            paths, err := handler(nextHop)
            if err != nil {
                continue
            }
            allPaths = append(allPaths, paths...)
        }
    case "first":
        // 只处理第一条路径
        if len(nextHops) > 0 {
            paths, err := handler(nextHops[0])
            if err != nil {
                return nil, err
            }
            allPaths = append(allPaths, paths...)
        }
    case "random":
        // 随机选择一条路径
        // ...
    case "round-robin":
        // 轮询选择路径
        // ...
    }
    
    return allPaths, nil
}
```

---

## 5. 使用示例

### 5.1 基本路由查询

```go
// 使用routing项目进行路由查询
import "github.com/netxops/l2service/pkg/routing"

// 创建路由表
routeTable := routing.NewRouteTable("default", network.IPv4)

// 添加路由
net, _ := network.ParseIPNet("10.0.0.0/8")
nextHop := routing.NewNextHop("GigabitEthernet0/0", "192.168.1.1", false)
routeTable.AddRoute(net, nextHop)

// 查询路由
query := routing.NewRouteQuery(routeTable)
dst, _ := network.NewNetworkList("10.0.0.1/32")
result, err := query.QueryRoute(dst, "GigabitEthernet0/1", "default", network.IPv4)

if err == nil && result.Matched {
    fmt.Printf("找到路由，输出接口: %v\n", result.OutPorts)
    fmt.Printf("下一跳: %v\n", result.NextHops)
}
```

### 5.2 路径计算

```go
// 使用routing项目进行路径计算
import "github.com/netxops/l2service/pkg/routing"

// 创建拓扑
topology := routing.NewTopology()

// 添加节点
node1 := topology.AddNode(&routing.NodeConfig{
    ID:   "node1",
    Name: "Router1",
})

// 设置路由表
routeTable := routing.NewRouteTable("default", network.IPv4)
// ... 添加路由 ...
node1.SetRouteTable("default", network.IPv4, routeTable)

// 创建路径计算器
options := &routing.PathQueryOptions{
    Source:      srcNetwork,
    Destination: dstNetwork,
    VRF:         "default",
    EnableECMP:  true,
    MaxPaths:    100,
}

calculator := routing.NewPathCalculator(topology, options)

// 计算路径
paths, err := calculator.CalculatePath(ctx)
if err != nil {
    log.Fatal(err)
}

// 处理路径结果
for _, path := range paths {
    fmt.Printf("路径 %s: 成功=%v, 跳数=%d\n", 
        path.PathID, path.Success, path.TotalHops)
    for _, hop := range path.Hops {
        fmt.Printf("  %s:%s -> %s:%s\n", 
            hop.Node, hop.InPort, hop.Node, hop.OutPort)
    }
}
```

### 5.3 nodemap中使用

```go
// 在nodemap中使用routing项目
import (
    "github.com/influxdata/telegraf/controller/pkg/nodemap"
    "github.com/netxops/utils/policy"
)

// 创建NodeMap
nodeMap, ctx := nodemap.NewNodeMapFromNetwork("test", deviceList, false, 1, nil)

// 创建策略意图
intent := &policy.Intent{
    PolicyEntry: *policyEntry,
    // ...
}

// 使用routing项目计算路径
calculator := nodemap.NewNodeMapPathCalculator(nodeMap)
paths, err := calculator.CalculatePathFromIntent(ctx, intent, "default", "", "")

// 处理路径，生成防火墙策略
for _, path := range paths {
    for _, hop := range path.Hops {
        node := nodeMap.GetNode(hop.Node)
        if node.NodeType() == api.FIREWALL {
            // 处理防火墙策略
            processFirewallPolicy(node, hop, intent)
        }
    }
}
```

---

## 6. 实施步骤

### 阶段1：创建routing项目（1-2周）

1. **创建项目结构**
   ```bash
   mkdir -p pkg/routing/{core,model,graph,multipath,query,example}
   ```

2. **定义核心接口**
   - `Topology` 接口
   - `Node` 接口
   - `Port` 接口
   - `PathCalculator` 接口

3. **实现基础数据模型**
   - `RouteResult`
   - `PathResult`
   - `PathHop`

### 阶段2：实现核心功能（2-3周）

1. **路由表管理**
   - 封装 `AddressTable`
   - 实现路由添加和查询

2. **路由查询**
   - 实现 `RouteQuery`
   - 支持单路径和多路径查询

3. **路径计算**
   - 实现 `PathCalculator`
   - 实现递归路径计算

4. **节点定位**
   - 实现 `NodeLocator`
   - 支持多种定位策略

### 阶段3：实现多路径支持（2-3周）

1. **路径跟踪系统**
   - 实现 `PathTracker`
   - 实现路径状态管理
   - 实现节点路径映射

2. **ECMP支持**
   - 实现ECMP处理
   - 支持路径选择策略

3. **结果合并**
   - 实现结果合并机制
   - 支持去重和优化

### 阶段4：nodemap集成（1-2周）

1. **创建适配层**
   - 实现 `NodeMapTopologyAdapter`
   - 实现 `NodeAdapter`、`PortAdapter`、`ConnectorAdapter`

2. **修改TraverseProcess**
   - 使用 `routing.PathCalculator`
   - 保持向后兼容

3. **测试和验证**
   - 单元测试
   - 集成测试

### 阶段5：优化和完善（1-2周）

1. **性能优化**
   - 路径计算性能优化
   - 内存使用优化

2. **功能完善**
   - 添加更多查询选项
   - 完善错误处理

3. **文档完善**
   - API文档
   - 使用示例

---

## 7. 优势分析

### 7.1 通用性

- ✅ **独立于业务逻辑**：routing项目不依赖防火墙策略
- ✅ **可复用**：可以被多种运维工具使用
- ✅ **清晰的接口**：提供清晰的API接口

### 7.2 可维护性

- ✅ **职责分离**：路由处理和业务逻辑分离
- ✅ **易于测试**：独立的项目更容易测试
- ✅ **易于扩展**：新功能更容易添加

### 7.3 多路径支持

- ✅ **原生支持**：在routing项目中直接支持多路径
- ✅ **路径跟踪**：完整的路径跟踪系统
- ✅ **结果合并**：自动合并相同节点的结果

### 7.4 兼容性

- ✅ **向后兼容**：nodemap通过适配层使用，保持兼容
- ✅ **渐进式迁移**：可以逐步迁移，不影响现有功能

---

## 8. 总结

### 8.1 核心要点

1. **拆分策略**：将路由处理能力拆分为独立的通用项目
2. **接口抽象**：通过接口抽象化，移除对防火墙策略的依赖
3. **多路径支持**：在通用项目中直接实现多路径支持
4. **适配层设计**：nodemap通过适配层使用routing项目

### 8.2 关键设计

- **Topology接口**：抽象网络拓扑，不依赖具体实现
- **PathCalculator**：通用的路径计算器，不依赖业务逻辑
- **PathTracker**：完整的路径跟踪系统，支持多路径
- **适配层**：nodemap通过适配层使用routing项目

### 8.3 实施建议

1. **先实现routing项目**：确保核心功能完整
2. **再实现多路径**：在routing项目中直接支持多路径
3. **最后集成nodemap**：通过适配层集成，保持兼容

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX

