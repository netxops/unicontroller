# 节点定位机制分析

## 1. 整体架构

节点定位机制采用**策略模式（Strategy Pattern）**实现，通过策略链按优先级依次尝试不同的定位策略，直到找到匹配的节点或所有策略都失败。

### 1.1 核心组件

- **NodeLocator**: 节点定位器，负责协调各个策略的执行
- **LocatorStrategy**: 定位策略接口，定义了 `CanHandle` 和 `Locate` 方法
- **LocateRequest**: 定位请求，包含所有定位所需的信息
- **BaseLocatorStrategy**: 基础策略类，提供公共功能

### 1.2 策略执行流程

```
NodeLocator.Locate()
    ↓
创建 LocateRequest
    ↓
遍历策略列表（按优先级）
    ↓
策略.CanHandle(req) → 判断是否可以处理
    ↓ (可以处理)
策略.Locate(req) → 执行定位
    ↓ (成功)
返回节点和端口
    ↓ (失败)
继续下一个策略
    ↓ (所有策略都失败)
返回失败
```

## 2. 定位策略（按优先级排序）

### 2.1 NodeNameLocator（优先级 1 - 最高）

**用途**: 通过节点名称直接定位节点

**CanHandle 条件**:
- `req.NodeName != ""` - 必须有节点名称

**定位逻辑**:
1. 通过节点名称从 NodeMap 中获取节点
2. 如果指定了 `area`，通过 area 信息查找接口
3. 否则通过路由检查（`IpRouteCheck`）定位端口

**适用场景**:
- 明确知道节点名称的情况
- 最直接、最快速的定位方式

**代码位置**: `pkg/nodemap/node_name_locator.go`

---

### 2.2 SecurityZoneLocator（优先级 2）

**用途**: 通过安全区域（Security Zone）匹配定位节点

**CanHandle 条件**:
- 源网络能够匹配到安全区域（通过 `MatchSecurityZone`）

**定位逻辑**:
1. 使用 `AddressTable` 实现最长掩码匹配（最新实现）
2. 默认路由不参与匹配过程
3. 只有出现路由分歧（多个不同的 zone）或无法匹配时，才使用默认路由
4. 通过 `ConfigZoneName` 与防火墙设备的接口的 `Zone()` 进行匹配，确定接口
5. 如果没有 `ConfigZoneName`，通过路由查询确定接口

**适用场景**:
- 防火墙环境
- 需要根据源地址匹配安全区域的情况
- 支持最长掩码匹配，更精确

**代码位置**: 
- `pkg/nodemap/security_zone_locator.go`
- `pkg/nodemap/security_zone_matcher.go`

**关键改进**:
- ✅ 使用 `AddressTable` 实现最长匹配
- ✅ 默认路由仅在路由分歧或无法匹配时使用
- ✅ 支持优先级选择（多个 zone 时选择优先级最高的）

---

### 2.3 NetworkLocator（优先级 3）

**用途**: 通过网络地址匹配端口，从而定位节点

**CanHandle 条件**:
- 源网络能够匹配到端口（通过 `SelectPortListByNetwork`）

**定位逻辑**:
1. 遍历源网络列表，通过 `SelectPortListByNetwork` 查找匹配的端口
2. 如果找到多个端口：
   - 检查是否都在同一个节点（通过 `PortListIsSameNodeValidator`）
   - 如果不在同一节点，且提供了网关（`Gw`），通过网关 IP 匹配节点
   - 如果在同一节点，返回第一个端口
3. 如果只找到一个端口，直接返回

**适用场景**:
- 已知源 IP 地址
- 需要根据 IP 地址查找对应的网络接口
- 支持通过网关 IP 解决多节点冲突

**代码位置**: `pkg/nodemap/network_locator.go`

---

### 2.4 StubNodeLocator（优先级 4）

**用途**: 定位 Stub 节点（末梢节点）

**CanHandle 条件**:
- 前面的网络地址定位失败（端口列表为空）

**定位逻辑**:
1. 调用 `LocateStubNode` 查找 Stub 节点
2. 如果找到，返回 Stub 节点和端口

**适用场景**:
- 网络地址定位失败时
- 查找末梢网络节点

**代码位置**: `pkg/nodemap/stub_node_locator.go`

---

### 2.5 OutsideNodeLocator（优先级 5 - 最低）

**用途**: 定位 Outside 节点（外部网络节点）

**CanHandle 条件**:
- 总是可以尝试（作为最后的备选方案）

**定位逻辑**:
1. 查找所有有 Outside 连接的节点
2. 如果没有 Outside 节点：
   - 如果 NodeMap 中只有一台设备，通过路由查询接口检查
3. 如果只有一个 Outside 节点：
   - 优先通过路由表查找源 IP 应该从哪个接口出去
   - 如果失败，回退到使用默认网关的输出接口
4. 如果有多个 Outside 节点：
   - 必须提供 `area` 信息
   - 通过 area 信息匹配节点和接口
   - 通过路由检查验证节点是否能够路由目标网络

**适用场景**:
- 所有其他策略都失败时
- 定位外部网络出口节点
- 作为最后的备选方案

**代码位置**: `pkg/nodemap/outside_node_locator.go`

---

## 3. LocateRequest 结构

```go
type LocateRequest struct {
    SrcNetList       *network.NetworkList  // 源网络列表
    DstNetList       *network.NetworkList  // 目标网络列表
    NodeName         string                // 节点名称
    Vrf              string                // VRF 名称
    Gw               string                // 网关地址
    Area             string                // 区域名称
    IPFamily         network.IPFamily      // IP 协议族（IPv4/IPv6）
    NodeMap          *NodeMap              // NodeMap 实例
    Logger           *zap.Logger           // 日志记录器
    
    // 内部字段（由策略设置和使用）
    securityZoneInfo *config.SecurityZoneInfo  // 安全区域信息
    portList         []api.Port               // 端口列表
    portListMap      map[api.Port]bool        // 端口映射
}
```

## 4. 策略之间的协作

### 4.1 信息传递

策略之间通过 `LocateRequest` 共享信息：

- **SecurityZoneLocator** 在 `CanHandle` 中设置 `securityZoneInfo`，供 `Locate` 使用
- **NetworkLocator** 在 `CanHandle` 中设置 `portList` 和 `portListMap`
- **StubNodeLocator** 检查 `portList` 是否为空，判断前面的策略是否失败

### 4.2 失败处理

- 如果策略返回 `false` 但错误信息为空，继续尝试下一个策略
- 如果策略返回 `false` 且有错误信息，记录日志但继续尝试下一个策略
- 只有所有策略都失败时，才返回最终失败

## 5. 关键特性

### 5.1 最长匹配支持

**SecurityZoneLocator** 使用 `AddressTable` 实现最长掩码匹配：
- 使用 `MatchNetList(*netList, true, false)` - 第二个参数 `true` 表示最长匹配
- 默认路由不参与匹配过程
- 只有出现路由分歧或无法匹配时，才使用默认路由

### 5.2 优先级机制

- 策略按优先级顺序执行
- 高优先级策略成功时，不会尝试低优先级策略
- 多个匹配结果时，选择优先级最高的（数字越小越优先）

### 5.3 多节点冲突处理

- **NetworkLocator**: 通过网关 IP（`Gw`）解决多节点冲突
- **OutsideNodeLocator**: 通过区域信息（`Area`）解决多节点冲突
- 如果无法解决冲突，返回失败

### 5.4 VRF 支持

- 所有策略都支持 VRF 参数
- 在匹配时考虑 VRF 信息，确保路由表匹配正确

## 6. 使用示例

```go
// 创建 NodeLocator
locator := NewNodeLocator(nodeMap, logger)

// 创建源网络和目标网络
srcNetList := network.NewNetworkList(...)
dstNetList := network.NewNetworkList(...)

// 执行定位
ok, node, portName := locator.Locate(
    srcNetList,
    dstNetList,
    "node-name",  // 节点名称（可选）
    "vrf1",       // VRF（可选）
    "192.168.1.1", // 网关（可选）
    "area1",      // 区域（可选）
)

if ok {
    fmt.Printf("Found node: %s, port: %s\n", node.Name(), portName)
} else {
    fmt.Println("Failed to locate node")
}
```

## 7. 改进建议

### 7.1 已实现的改进

✅ **SecurityZoneLocator 使用 AddressTable 实现最长匹配**
- 更精确的匹配算法
- 默认路由仅在必要时使用

### 7.2 可能的改进方向

1. **策略缓存**: 对频繁使用的策略结果进行缓存
2. **策略权重**: 根据历史成功率动态调整策略优先级
3. **并行策略**: 对于独立的策略，可以并行执行以提高性能
4. **更详细的错误信息**: 提供更具体的失败原因，便于调试

## 8. 总结

节点定位机制采用策略模式，通过多个定位策略按优先级依次尝试，实现了灵活、可扩展的节点定位功能。每个策略针对不同的场景和条件，最终确保在各种情况下都能找到合适的节点和端口。

**关键优势**:
- ✅ 策略模式，易于扩展和维护
- ✅ 优先级机制，确保最合适的策略优先执行
- ✅ 信息共享，策略之间可以协作
- ✅ 最长匹配支持，提高匹配精度
- ✅ 完善的错误处理和日志记录

