# 多路径（ECMP）支持方案

## 1. 概述

当前系统不支持多路径路由（ECMP - Equal Cost Multi-Path），当遇到多条等价路由时会报错。本文档提供完整的多路径支持实现方案。

### 1.1 当前限制

系统在以下位置限制了多路径：

1. **路由查询限制** (`pkg/nodemap/node/node.go:IpRouteCheck`)
   ```go
   if rmr.Match.Len() > 1 {
       same, _ := rmr.IsSameIp()
       if !same {
           return false, nil, nil, fmt.Errorf("current not support multiple match route: %v", rmr)
       }
   }
   ```

2. **路径计算限制** (`pkg/nodemap/traverse.go:RunL3Route`)
   ```go
   } else if len(hopTable.Column("connected").List().Distinct()) > 1 {
       errStr := fmt.Sprintf("不支持多路由匹配: 连接=%v", hopTable.Column("connected").List())
       return model.NewProcessErr(errStr, model.Not_Support_Multi_Route)
   }
   ```

### 1.2 多路径场景

多路径路由常见于以下场景：
- **ECMP（等价多路径）**: 多条到同一目标的等价路由
- **负载均衡**: 通过多条路径分发流量
- **冗余路径**: 提供路径冗余和故障切换

---

## 2. 设计方案

### 2.1 核心设计理念

**路径跟踪系统是支持多路径的基础**

多路径支持不仅仅是"移除限制"，更重要的是建立完整的路径跟踪系统：

1. **路径标识系统**：为每条路径分配唯一ID，跟踪路径状态
2. **节点路径映射**：记录每个节点被哪些路径访问
3. **结果合并机制**：正确合并相同节点在不同路径上的处理结果
4. **路径状态管理**：跟踪每条路径的状态（进行中、成功、失败）

详细设计请参考：`路径跟踪系统设计.md`

### 2.2 架构设计

支持多路径需要修改以下组件：

```
┌─────────────────────────────────────────────────────────┐
│              IpRouteCheck (路由查询)                      │
│  - 返回所有可能的下一跳（不再限制为单个）                  │
│  - 支持ECMP路由识别                                       │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│           RunL3Route (路径计算)                          │
│  - 遍历所有可能的下一跳                                    │
│  - 为每个下一跳创建独立的路径分支                          │
│  - 支持路径去重和环路检测                                  │
└─────────────────────────────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────┐
│          TraverseResult (结果存储)                        │
│  - 支持多条路径存储                                        │
│  - 路径标识和去重                                          │
└─────────────────────────────────────────────────────────┘
```

### 2.2 数据结构扩展

#### 2.2.1 路径标识

为每条路径添加唯一标识：

```go
type PathID string

func GeneratePathID(nodeName, vrf, inPort, outPort string) PathID {
    return PathID(fmt.Sprintf("%s:%s:%s->%s", vrf, nodeName, inPort, outPort))
}
```

#### 2.2.2 多路径结果结构

扩展 `TraverseResult` 支持多条路径：

```go
type TraverseResult struct {
    Items []*TraverseResultItem
    err   model.ProcessErr
    // 新增：多路径支持
    Paths []*PathResult  // 所有路径结果
}

type PathResult struct {
    PathID      PathID              // 路径唯一标识
    Path        []*PathHop          // 路径跳列表
    Success     bool                // 是否成功到达目标
    Error       model.ProcessErr   // 错误信息（如果有）
    NodeResults map[string]*TraverseResultItem  // 每个节点的处理结果
}

type PathHop struct {
    Node      api.Node
    InPort    api.Port
    OutPort   api.Port
    Vrf       string
    NextHopIP string
    IsECMP    bool  // 是否为ECMP路径
}
```

---

## 3. 实现方案

### 3.0 路径跟踪系统（核心组件）

**必须先实现路径跟踪系统，才能支持多路径**

路径跟踪系统包括：

1. **PathTracker**：路径跟踪器，管理所有路径的状态
2. **PathID**：路径唯一标识
3. **PathStateInfo**：路径状态信息
4. **NodePathResult**：节点在特定路径上的处理结果

详细实现请参考：`路径跟踪系统设计.md`

### 3.1 修改 IpRouteCheck 方法

**文件**: `pkg/nodemap/node/node.go`

**修改点**: 移除多路径限制，返回所有可能的下一跳

```go
func (node *DeviceNode) IpRouteCheck(
    netList network.NetworkList, 
    inPort, vrf string, 
    af network.IPFamily) (bool, *tools.Table, []string, error) {
    
    var routeTable *network.AddressTable
    if af == network.IPv4 {
        routeTable = node.Ipv4RouteTable(vrf)
    } else {
        routeTable = node.Ipv6RouteTable(vrf)
    }
    
    if routeTable == nil {
        return false, nil, nil, nil
    }
    
    rmr := routeTable.MatchNetList(netList, true, false)
    if rmr.Unmatch != nil && rmr.Unmatch.Len() > 0 {
        return false, nil, nil, nil
    }
    
    // ========== 修改点：支持多路径 ==========
    // 移除多路径限制，允许返回多个下一跳
    // 不再检查 IsSameIp，直接返回所有匹配的路由
    
    match, _ := rmr.Table()
    outInterfaces := match.Column("interface").List().Distinct()
    
    var outPortList []string
    for _, p := range outInterfaces {
        if p.(string) == inPort {
            return false, nil, nil, fmt.Errorf("node: %s, inPort %s in %+v", 
                node.Name(), inPort, outInterfaces)
        }
        outPortList = append(outPortList, p.(string))
    }
    
    // 返回所有可能的输出端口（支持多路径）
    return true, match, outPortList, nil
}
```

### 3.2 修改 RunL3Route 方法

**文件**: `pkg/nodemap/traverse.go`

**修改点**: 支持遍历所有可能的下一跳，为每个下一跳创建独立的路径分支

```go
func (tn *TraverseNode) RunL3Route(traverseOnly bool, ctx context.Context) (processErr model.ProcessErr) {
    // 1. 检查环路
    if _, exists := tn.Process.Vertices[tn.Key()]; exists {
        return
    }
    tn.Process.AddVertex(tn)
    
    // 2. 执行路由查询
    dstNetworkList := tn.Intent.Dst().NetworkList(tn.IPFamily)
    ok, hopTable, _, _ := tn.Node.IpRouteCheck(
        *dstNetworkList, 
        tn.InPort.Name(), 
        tn.InVrf, 
        tn.IPFamily)
    
    if !ok {
        return model.NewProcessErr("路由查询失败", model.RouteQuery)
    }
    
    // 3. 检查路由类型
    connectedList := hopTable.Column("connected").List().Distinct()
    
    // ========== 修改点1：移除多路径限制 ==========
    // 移除以下代码：
    // } else if len(hopTable.Column("connected").List().Distinct()) > 1 {
    //     return model.NewProcessErr(errStr, model.Not_Support_Multi_Route)
    // }
    
    // 3.1 直连路由：目标网络直接连接
    if len(connectedList) > 0 && connectedList[0].(bool) {
        // 检查是否有多个直连路由（多路径直连）
        if len(connectedList) == 1 {
            // 单一直连路由
            tn.Ok = true
            path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
            tn.Path += "|" + path
            return
        } else {
            // 多个直连路由（多路径直连）- 这种情况较少见，但需要支持
            tn.Ok = true
            path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
            tn.Path += "|" + path
            // 注意：多路径直连时，所有路径都标记为成功
            return
        }
    }
    
    // 3.2 非直连路由：需要查找下一跳
    // ========== 修改点2：遍历所有可能的下一跳 ==========
    var nextHops []*NextHopInfo
    
    for it := hopTable.Iterator(); it.HasNext(); {
        _, hopMap := it.Next()
        hopIp := hopMap["ip"].(string)
        outPortName := hopMap["interface"].(string)
        
        outPort := tn.Node.GetPortByNameOrAlias(outPortName)
        if outPort == nil {
            continue
        }
        
        outPortConnector := tn.nm.CxMananger.GetConnectorByID(outPort.ConnectorID())
        nextDeviceNode, nextInputPort := outPortConnector.SelectNodeByIp(hopIp, outPort.Vrf())
        
        if nextDeviceNode != nil {
            // 找到下一跳节点
            nextHops = append(nextHops, &NextHopInfo{
                NextNode:     nextDeviceNode,
                NextInputPort: nextInputPort,
                OutPort:      outPort,
                HopIP:        hopIp,
                OutPortName:   outPortName,
            })
        } else {
            // 处理Outside或Stub
            if ok, area := tn.nm.IsOutsidePort(tn.Node.Name(), outPortName, tn.IPFamily); ok {
                // Outside处理逻辑...
                // 注意：Outside也可能有多条路径
            } else if tn.nm.IsStubPort(tn.Node, outPort, tn.IPFamily) {
                // Stub处理逻辑...
            }
        }
    }
    
    // ========== 修改点3：为每个下一跳创建独立的路径分支 ==========
    if len(nextHops) == 0 {
        return model.NewProcessErr("未找到下一跳", model.NextHop_Empty)
    }
    
    // 如果只有一个下一跳，保持原有逻辑
    if len(nextHops) == 1 {
        nh := nextHops[0]
        path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
        nextNode := NewTraverseNode(
            tn.nm, nh.NextNode, tn.Intent.Copy().(*policy.Intent),
            nh.NextInputPort.Vrf(), nh.NextInputPort,
            tn.IPFamily, tn.Path+"|"+path, tn.Process, traverseOnly)
        nextNode.WithLogger(tn.logger)
        
        if _, exists := tn.Process.Vertices[nextNode.Key()]; !exists {
            tn.Process.AddVertex(nextNode)
            tn.Process.AddEdge(tn.Key(), nextNode.Key())
            processErr = nextNode.Run(traverseOnly, ctx)
            if processErr.NotNil() {
                return
            }
        }
        return
    }
    
    // 多个下一跳：创建多个路径分支
    // 注意：这里需要为每个分支创建独立的TraverseNode
    for _, nh := range nextHops {
        // 检查是否已访问（避免环路）
        pathKey := fmt.Sprintf("%s:%s:%s->%s", 
            nh.NextInputPort.Vrf(), nh.NextNode.Name(), 
            nh.NextInputPort.Name(), nh.OutPortName)
        
        // 创建新的路径分支
        path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
        nextNode := NewTraverseNode(
            tn.nm, nh.NextNode, tn.Intent.Copy().(*policy.Intent),
            nh.NextInputPort.Vrf(), nh.NextInputPort,
            tn.IPFamily, tn.Path+"|"+path, tn.Process, traverseOnly)
        nextNode.WithLogger(tn.logger)
        
        // 标记为ECMP路径
        // 可以通过扩展TraverseNode结构来标记
        
        if _, exists := tn.Process.Vertices[nextNode.Key()]; !exists {
            tn.Process.AddVertex(nextNode)
            tn.Process.AddEdge(tn.Key(), nextNode.Key())
            
            // 递归处理每个分支
            // 注意：这里需要并发或顺序处理，取决于需求
            processErr = nextNode.Run(traverseOnly, ctx)
            // 对于多路径，我们可能需要收集所有路径的结果
            // 而不是在第一个错误时返回
        }
    }
    
    return
}

// 新增：下一跳信息结构
type NextHopInfo struct {
    NextNode      api.Node
    NextInputPort api.Port
    OutPort       api.Port
    HopIP         string
    OutPortName   string
}
```

### 3.3 扩展 TraverseNode 结构

**文件**: `pkg/nodemap/traverse.go`

添加多路径相关字段：

```go
type TraverseNode struct {
    nm     *NodeMap
    Node   api.Node
    Intent *policy.Intent
    InVrf  string
    InPort api.Port
    Neighbor map[interface{}]graph.Vertex
    IPFamily network.IPFamily
    Path     string
    Ok       bool
    Info     string
    Process  *TraverseProcess
    TraverseOnly bool
    logger *zap.Logger
    
    // ========== 新增：多路径支持 ==========
    PathID      PathID    // 当前路径ID
    IsECMP      bool      // 是否为ECMP路径
    ECMPGroup   int       // ECMP组ID（同一ECMP组的路径共享组ID）
    ParentPathID PathID   // 父路径ID（用于追踪路径分支）
}
```

### 3.4 路径去重和合并

添加路径去重逻辑，避免重复计算相同路径：

```go
// 路径去重键
func (tn *TraverseNode) PathKey() string {
    return fmt.Sprintf("%s:%s:%s->%s", 
        tn.InVrf, tn.Node.Name(), 
        tn.InPort.Name(), tn.OutPortName())
}

// 检查路径是否已存在
func (tp *TraverseProcess) HasPath(pathID PathID) bool {
    for _, path := range tp.Results.Paths {
        if path.PathID == pathID {
            return true
        }
    }
    return false
}

// 添加路径结果
func (tp *TraverseProcess) AddPath(path *PathResult) {
    // 检查去重
    if tp.HasPath(path.PathID) {
        return
    }
    tp.Results.Paths = append(tp.Results.Paths, path)
}
```

---

## 4. 配置选项

### 4.1 多路径策略配置

添加配置选项控制多路径行为：

```go
type MultiPathConfig struct {
    EnableECMP      bool  // 是否启用ECMP
    MaxPaths        int   // 最大路径数量（0表示无限制）
    PathSelection   string // 路径选择策略：all, first, random, round-robin
    MergeResults    bool  // 是否合并相同节点的结果
}

// 在 TraverseProcess 中添加
type TraverseProcess struct {
    // ... 现有字段
    MultiPathConfig *MultiPathConfig  // 多路径配置
}
```

### 4.2 路径选择策略

支持不同的路径选择策略：

```go
const (
    PathSelectionAll        = "all"         // 遍历所有路径
    PathSelectionFirst      = "first"       // 只选择第一条路径
    PathSelectionRandom     = "random"      // 随机选择一条路径
    PathSelectionRoundRobin = "round-robin" // 轮询选择路径
)
```

---

## 5. 实现步骤

### 阶段0：路径跟踪系统（必须先实现）

**这是支持多路径的基础，必须先完成**

1. **实现 PathTracker**
   - 创建路径跟踪器核心数据结构
   - 实现路径状态管理方法
   - 实现节点路径映射
   - 实现结果合并机制

2. **扩展 TraverseProcess**
   - 添加 `PathTracker` 字段
   - 添加 `EnableMultiPath` 和 `MaxPaths` 配置

3. **扩展 TraverseNode**
   - 添加 `PathID`、`ParentPathID`、`NodeKey` 等字段
   - 修改 `NewTraverseNode` 支持路径跟踪

4. **测试路径跟踪系统**
   - 单路径场景（确保路径跟踪正常工作）
   - 路径状态管理测试
   - 节点路径映射测试

### 阶段1：基础支持（最小改动）

1. **移除多路径限制**
   - 修改 `IpRouteCheck` 移除多路径检查
   - 修改 `RunL3Route` 移除多路径错误返回

2. **集成路径跟踪系统**
   - 在 `RunL3Route` 中使用 `PathTracker` 跟踪路径
   - 为每个下一跳创建独立的路径ID
   - 使用路径跟踪进行环路检测

3. **支持多下一跳遍历**
   - 修改 `RunL3Route` 遍历所有下一跳
   - 为每个下一跳创建独立的 `TraverseNode` 和路径

4. **测试验证**
   - 单路径场景（确保不影响现有功能）
   - 双路径ECMP场景

### 阶段2：结果管理（中等改动）

1. **实现结果合并机制**
   - 使用 `PathTracker.MergeNodeResults` 合并结果
   - 在 `TraverseProcess.CollectResults` 中收集和合并所有路径的结果
   - 避免重复生成配置

2. **路径统计和分析**
   - 实现路径统计信息收集
   - 提供路径分析接口
   - 记录路径成功率和性能指标

3. **结果去重优化**
   - 优化命令列表去重逻辑
   - 优化配置合并策略

### 阶段3：高级功能（可选）

1. **路径选择策略**
   - 实现不同的路径选择策略
   - 支持配置化选择

2. **路径权重和优先级**
   - 支持路径权重
   - 按权重选择路径

3. **路径统计和分析**
   - 路径数量统计
   - 路径性能分析

---

## 6. 代码示例

### 6.1 修改后的 IpRouteCheck

```go
func (node *DeviceNode) IpRouteCheck(
    netList network.NetworkList, 
    inPort, vrf string, 
    af network.IPFamily) (bool, *tools.Table, []string, error) {
    
    var routeTable *network.AddressTable
    if af == network.IPv4 {
        routeTable = node.Ipv4RouteTable(vrf)
    } else {
        routeTable = node.Ipv6RouteTable(vrf)
    }
    
    if routeTable == nil {
        return false, nil, nil, nil
    }
    
    rmr := routeTable.MatchNetList(netList, true, false)
    if rmr.Unmatch != nil && rmr.Unmatch.Len() > 0 {
        return false, nil, nil, nil
    }
    
    // 支持多路径：不再检查 IsSameIp
    match, _ := rmr.Table()
    outInterfaces := match.Column("interface").List().Distinct()
    
    var outPortList []string
    for _, p := range outInterfaces {
        if p.(string) == inPort {
            return false, nil, nil, fmt.Errorf("node: %s, inPort %s in %+v", 
                node.Name(), inPort, outInterfaces)
        }
        outPortList = append(outPortList, p.(string))
    }
    
    return true, match, outPortList, nil
}
```

### 6.2 修改后的 RunL3Route（核心部分）

```go
func (tn *TraverseNode) RunL3Route(traverseOnly bool, ctx context.Context) (processErr model.ProcessErr) {
    // ... 前面的检查逻辑保持不变 ...
    
    // 收集所有可能的下一跳
    var nextHops []*NextHopInfo
    
    for it := hopTable.Iterator(); it.HasNext(); {
        _, hopMap := it.Next()
        hopIp := hopMap["ip"].(string)
        outPortName := hopMap["interface"].(string)
        outPort := tn.Node.GetPortByNameOrAlias(outPortName)
        
        if outPort == nil {
            continue
        }
        
        outPortConnector := tn.nm.CxMananger.GetConnectorByID(outPort.ConnectorID())
        nextDeviceNode, nextInputPort := outPortConnector.SelectNodeByIp(hopIp, outPort.Vrf())
        
        if nextDeviceNode != nil {
            nextHops = append(nextHops, &NextHopInfo{
                NextNode:      nextDeviceNode,
                NextInputPort: nextInputPort,
                OutPort:       outPort,
                HopIP:         hopIp,
                OutPortName:   outPortName,
            })
        }
        // ... 处理Outside和Stub ...
    }
    
    // 处理多个下一跳
    if len(nextHops) > 1 {
        // ECMP场景：为每个下一跳创建路径分支
        for _, nh := range nextHops {
            path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
            nextNode := NewTraverseNode(
                tn.nm, nh.NextNode, tn.Intent.Copy().(*policy.Intent),
                nh.NextInputPort.Vrf(), nh.NextInputPort,
                tn.IPFamily, tn.Path+"|"+path, tn.Process, traverseOnly)
            nextNode.WithLogger(tn.logger)
            nextNode.IsECMP = true  // 标记为ECMP路径
            
            if _, exists := tn.Process.Vertices[nextNode.Key()]; !exists {
                tn.Process.AddVertex(nextNode)
                tn.Process.AddEdge(tn.Key(), nextNode.Key())
                nextNode.Run(traverseOnly, ctx)
            }
        }
    } else if len(nextHops) == 1 {
        // 单一路径：保持原有逻辑
        nh := nextHops[0]
        path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
        nextNode := NewTraverseNode(
            tn.nm, nh.NextNode, tn.Intent.Copy().(*policy.Intent),
            nh.NextInputPort.Vrf(), nh.NextInputPort,
            tn.IPFamily, tn.Path+"|"+path, tn.Process, traverseOnly)
        nextNode.WithLogger(tn.logger)
        
        if _, exists := tn.Process.Vertices[nextNode.Key()]; !exists {
            tn.Process.AddVertex(nextNode)
            tn.Process.AddEdge(tn.Key(), nextNode.Key())
            processErr = nextNode.Run(traverseOnly, ctx)
        }
    }
    
    return
}
```

---

## 7. 测试方案

### 7.1 单元测试

```go
func TestMultiPathRouteCheck(t *testing.T) {
    // 测试多路径路由查询
    node := createTestNode()
    
    // 创建包含多条等价路由的路由表
    netList := network.NewNetworkList()
    netList.Add(network.ParseIPNet("10.0.0.0/8"))
    
    ok, hopTable, outPorts, err := node.IpRouteCheck(
        *netList, "GigabitEthernet0/0", "default", network.IPv4)
    
    assert.True(t, ok)
    assert.NoError(t, err)
    assert.Greater(t, len(outPorts), 1, "应该返回多个输出端口")
}
```

### 7.2 集成测试

```go
func TestECMPPathTraversal(t *testing.T) {
    // 测试ECMP路径遍历
    nodeMap := createTestNodeMapWithECMP()
    
    intent := &policy.Intent{
        // ... 配置意图
    }
    
    tp := nodeMap.MakeTemplates(intent, ctx)
    
    // 验证生成了多条路径
    assert.Greater(t, len(tp.Results.Paths), 1, "应该生成多条路径")
    
    // 验证每条路径都成功
    for _, path := range tp.Results.Paths {
        assert.True(t, path.Success, "每条路径都应该成功")
    }
}
```

---

## 8. 注意事项

### 8.1 性能考虑

- **路径数量限制**: 对于大型网络，多路径可能导致路径数量爆炸式增长，需要设置最大路径数限制
- **内存使用**: 多条路径会占用更多内存，需要监控内存使用情况
- **计算时间**: 遍历所有路径会增加计算时间，可能需要超时机制

### 8.2 兼容性

- **向后兼容**: 确保单路径场景的行为不变
- **配置兼容**: 默认行为应该与现有系统一致（可以通过配置启用多路径）

### 8.3 错误处理

- **部分路径失败**: 当部分路径失败时，应该继续处理其他路径
- **路径合并**: 相同节点的结果需要正确合并，避免重复配置

---

## 9. 总结

支持多路径需要：

1. ✅ **路径跟踪系统**（核心）：实现完整的路径跟踪系统，这是支持多路径的基础
2. ✅ **移除限制**: 移除 `IpRouteCheck` 和 `RunL3Route` 中的多路径限制
3. ✅ **遍历所有下一跳**: 修改 `RunL3Route` 遍历所有可能的下一跳，使用路径跟踪系统
4. ✅ **结果合并**: 使用路径跟踪系统合并相同节点在不同路径上的结果
5. ✅ **配置选项**: 添加多路径配置选项

**关键点**：
- **路径跟踪系统是核心**：必须先实现路径跟踪系统，才能支持多路径
- **分阶段实现**：先实现路径跟踪系统，再移除限制，最后完善结果合并
- **向后兼容**：确保单路径场景的行为不变

**相关文档**：
- `路径跟踪系统设计.md`：详细的路径跟踪系统设计
- `多路径实现示例.go`：实现示例代码

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX

