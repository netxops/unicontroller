# è·¯ç”±ä¸è·¯å¾„è®¡ç®—æ·±åº¦åˆ†ææ–‡æ¡£

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£å¯¹ l2service é¡¹ç›®ä¸­çš„ **Adapterå±‚**ã€**Nodeå±‚** ä»¥åŠ **è·¯ç”±ä¸è·¯å¾„è®¡ç®—** éƒ¨åˆ†è¿›è¡Œæ·±åº¦åˆ†æï¼Œé‡ç‚¹å›´ç»•è·¯ç”±è¡¨ç®¡ç†ã€è·¯ç”±æŸ¥è¯¢ã€è·¯å¾„è®¡ç®—ç­‰æ ¸å¿ƒæœºåˆ¶å±•å¼€ã€‚

---

## 1. æ¶æ„æ¦‚è§ˆ

### 1.1 æ•´ä½“æ¶æ„

é¡¹ç›®é‡‡ç”¨ä¸‰å±‚æ¶æ„è®¾è®¡ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NodeMap (ç½‘ç»œæ‹“æ‰‘å±‚)                    â”‚
â”‚  - èŠ‚ç‚¹ç®¡ç† (Nodes)                                       â”‚
â”‚  - ç«¯å£ç®¡ç† (Ports)                                       â”‚
â”‚  - è¿æ¥å™¨ç®¡ç† (ConnectorManager)                          â”‚
â”‚  - è·¯å¾„éå† (TraverseProcess)                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â–²
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Node (è®¾å¤‡æŠ½è±¡å±‚)                       â”‚
â”‚  - DeviceNode: è®¾å¤‡èŠ‚ç‚¹æŠ½è±¡                              â”‚
â”‚  - VRFç®¡ç†: å¤šVRFæ”¯æŒ                                    â”‚
â”‚  - è·¯ç”±è¡¨ç®¡ç†: IPv4/IPv6è·¯ç”±è¡¨                           â”‚
â”‚  - è·¯ç”±æŸ¥è¯¢: IpRouteCheck                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â–²
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Adapter (è®¾å¤‡é€‚é…å±‚)                      â”‚
â”‚  - è®¾å¤‡è¿æ¥: é€šè¿‡SSH/CLI/API                             â”‚
â”‚  - é…ç½®è§£æ: è§£æè®¾å¤‡é…ç½®å’Œè·¯ç”±è¡¨                         â”‚
â”‚  - æ•°æ®æå–: PortList, RouteTable                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒæ•°æ®æµ

```
è®¾å¤‡é…ç½®/çŠ¶æ€
    â†“
Adapter (è§£æè·¯ç”±è¡¨ã€ç«¯å£ä¿¡æ¯)
    â†“
Node (æ„å»ºè·¯ç”±è¡¨ã€ç«¯å£åˆ—è¡¨)
    â†“
NodeMap (æ„å»ºç½‘ç»œæ‹“æ‰‘)
    â†“
TraverseProcess (è·¯å¾„è®¡ç®—)
    â†“
è·¯å¾„ç»“æœ
```

---

## 2. Adapterå±‚æ·±åº¦åˆ†æ

### 2.1 Adapteræ¥å£å®šä¹‰

**ä½ç½®**: `pkg/nodemap/api/api.go`

Adapteræ˜¯è®¾å¤‡é€‚é…å±‚çš„æŠ½è±¡æ¥å£ï¼Œè´Ÿè´£ä¸å…·ä½“ç½‘ç»œè®¾å¤‡è¿›è¡Œäº¤äº’ã€‚

```go
type Adapter interface {
    Write(p []byte) (n int, err error)
    // å…¶ä»–æ–¹æ³•é€šè¿‡æ¥å£ç»„åˆå®ç°
}

// FwAdapter æ˜¯é˜²ç«å¢™é€‚é…å™¨æ¥å£
type FwAdapter interface {
    Adapter
}

// å…³é”®æ–¹æ³•ï¼ˆé€šè¿‡æ¥å£ç»„åˆï¼‰
type DeviceAdapter interface {
    Adapter
    PortList(force bool) []api.Port
    RouteTable(force bool) (ipv4TableMap, ipv6TableMap map[string]*network.AddressTable)
    ParseName(force bool) string
    TaskId() uint
}
```

### 2.2 Adapterå·¥å‚æ¨¡å¼

**ä½ç½®**: `pkg/nodemap/factory.go`

ç³»ç»Ÿé€šè¿‡å·¥å‚æ¨¡å¼åˆ›å»ºä¸åŒç±»å‹çš„è®¾å¤‡é€‚é…å™¨ï¼š

```go
func NewAdapter(dc *config.DeviceConfig) api.Adapter {
    baseInfo := session.NewDeviceBaseInfo(dc.Host, dc.Username, dc.Password, dc.Mode, dc.Community, dc.Port)
    
    switch baseInfo.Type {
    case terminalmode.ASA:
        return ASA.NewASAAdapter(baseInfo, dc.Config)
    case terminalmode.IOS:
        return router.NewBaseIosAdapter(baseInfo, dc.Config)
    case terminalmode.SRX:
        return SRX.NewSRXAdapter(baseInfo, dc.Config)
    case terminalmode.SecPath:
        return SECPATH.NewSecPathAdapter(baseInfo, dc.Config)
    case terminalmode.FortiGate:
        return FortiGate.NewFortiAdapter(baseInfo, dc.Config)
    case terminalmode.Dptech:
        return DP.NewDptechAdapter(baseInfo, dc.Config)
    case terminalmode.HuaWei:
        return USG.NewUsgAdapter(baseInfo, dc.Config)
    // ... å…¶ä»–è®¾å¤‡ç±»å‹
    }
}
```

### 2.3 è·¯ç”±è¡¨è§£ææœºåˆ¶

#### 2.3.1 è·¯ç”±è¡¨è·å–æµç¨‹

æ¯ä¸ªAdapteréƒ½éœ€è¦å®ç° `RouteTable` æ–¹æ³•ï¼Œç”¨äºä»è®¾å¤‡è·å–è·¯ç”±è¡¨ä¿¡æ¯ï¼š

```go
func (adapter *SecPathAdapter) RouteTable(force bool) (ipv4TableMap, ipv6TableMap map[string]*network.AddressTable) {
    if adapter.Type == api.LiveAdapter {
        return adapter.liveAdapterRouteTable(force)
    } else if adapter.Type == api.StringAdapter {
        return adapter.stringAdapterRouteTable()
    }
    return map[string]*network.AddressTable{}, map[string]*network.AddressTable{}
}
```

#### 2.3.2 Live Adapterè·¯ç”±è¡¨è§£æ

**ä½ç½®**: `pkg/nodemap/adapter/fw/secpath/secpath.go`

å¯¹äºLive Adapterï¼Œç³»ç»Ÿé€šè¿‡APIæˆ–CLIè·å–å®æ—¶è·¯ç”±è¡¨ï¼š

```go
func (adapter *SecPathAdapter) parseRouteTable(v4, force bool) map[string]*network.AddressTable {
    var apiKey = "Ipv4Routes"
    if !v4 {
        apiKey = "Ipv6Routes"
    }
    
    // 1. é€šè¿‡APIè·å–è·¯ç”±æ•°æ®
    rMap, err := adapter.getAPI(apiKey, "", 5, force, false)
    if err != nil {
        panic(err)
    }
    
    resultTableMap := map[string]*network.AddressTable{}
    routeMapList := rMap[apiKey].([]interface{})
    
    // 2. è§£ææ¯æ¡è·¯ç”±
    for _, r := range routeMapList {
        var routeEntry xmlRouteStruct
        mapstructure.Decode(r, &routeEntry)
        
        // 3. åˆ¤æ–­æ˜¯å¦ä¸ºç›´è¿è·¯ç”±
        for _, port := range adapter.portList {
            if port.IfIndex() == int(routeEntry.IfIndex) {
                routeEntry.PortName = port.Name()
                // æ£€æŸ¥æ˜¯å¦ä¸ºç›´è¿è·¯ç”±
                net, _ := network.NewNetworkFromString(routeEntry.net())
                for _, addr := range port.Ipv4List() {
                    n, _ := network.NewNetworkFromString(addr)
                    if net.Same(n) {
                        routeEntry.Connected = true
                    }
                }
            }
        }
        
        // 4. æ„å»ºNextHopå¯¹è±¡
        nextHop := &network.NextHop{}
        nextHop.AddHop(routeEntry.PortName, routeEntry.Nexthop, routeEntry.Connected, false, nil)
        
        // 5. æ¨é€åˆ°è·¯ç”±è¡¨
        table := resultTableMap[routeEntry.VRF]
        net, _ := network.ParseIPNet(routeEntry.net())
        table.PushRoute(net, nextHop)
    }
    
    return resultTableMap
}
```

#### 2.3.3 String Adapterè·¯ç”±è¡¨è§£æ

å¯¹äºString Adapterï¼Œç³»ç»Ÿä»é…ç½®æ–‡æœ¬ä¸­è§£æè·¯ç”±è¡¨ï¼š

```go
func (adapter *SecPathAdapter) stringAdapterRouteTable() (ipv4TableMap, ipv6TableMap map[string]*network.AddressTable) {
    ipv4TableMap = make(map[string]*network.AddressTable)
    ipv6TableMap = make(map[string]*network.AddressTable)
    
    lines := strings.Split(adapter.current, "\n")
    
    for _, line := range lines {
        line = strings.TrimSpace(line)
        if strings.HasPrefix(line, "ip route-static") {
            parseIPv4Route(line, ipv4TableMap, adapter)
        } else if strings.HasPrefix(line, "ipv6 route-static") {
            parseIPv6Route(line, ipv6TableMap, adapter)
        }
    }
    
    return ipv4TableMap, ipv6TableMap
}

func parseIPv4Route(line string, tableMap map[string]*network.AddressTable, adapter *SecPathAdapter) {
    fields := strings.Fields(line)
    // è§£æVRFã€ç›®æ ‡ç½‘ç»œã€ä¸‹ä¸€è·³ç­‰ä¿¡æ¯
    // ...
    table := tableMap[vrf]
    net, _ := network.ParseIPNet(fmt.Sprintf("%s/%s", destination, mask))
    nextHopObj := &network.NextHop{}
    nextHopObj.AddHop(interface_, nextHop, false, false, nil)
    table.PushRoute(net, nextHopObj)
}
```

### 2.4 ç«¯å£åˆ—è¡¨è·å–

æ¯ä¸ªAdapterè¿˜éœ€è¦å®ç° `PortList` æ–¹æ³•ï¼Œç”¨äºè·å–è®¾å¤‡çš„ç«¯å£ä¿¡æ¯ï¼š

```go
func (adapter *SecPathAdapter) PortList(force bool) []api.Port {
    // 1. è·å–æ¥å£ä¿¡æ¯
    // 2. è§£ææ¥å£é…ç½®
    // 3. æ„å»ºPortå¯¹è±¡åˆ—è¡¨
    // 4. è¿”å›ç«¯å£åˆ—è¡¨
}
```

### 2.5 é€‚é…å™¨ç±»å‹æ€»ç»“

| é€‚é…å™¨ç±»å‹ | è®¾å¤‡ç±»å‹ | è·¯ç”±è¡¨è·å–æ–¹å¼ | å¤‡æ³¨ |
|-----------|---------|---------------|------|
| SecPathAdapter | åä¸ºSecPath | API/CLI | æ”¯æŒVRFéš”ç¦» |
| UsgAdapter | åä¸ºUSG | CLI | æ”¯æŒIPv4/IPv6 |
| SRXAdapter | Juniper SRX | CLI | æ”¯æŒZoneæ¦‚å¿µ |
| ASAAdapter | Cisco ASA | CLI | æ”¯æŒSecurity Level |
| FortiAdapter | Fortinet FortiGate | API/CLI | æ”¯æŒç­–ç•¥è·¯ç”± |
| BaseIosAdapter | Cisco IOS | CLI | æ”¯æŒå¤šç§è·¯ç”±åè®® |

---

## 3. Nodeå±‚æ·±åº¦åˆ†æ

### 3.1 Nodeæ¥å£å®šä¹‰

**ä½ç½®**: `pkg/nodemap/api/api.go`

Nodeæ˜¯è®¾å¤‡èŠ‚ç‚¹çš„æŠ½è±¡æ¥å£ï¼Œä»£è¡¨ç½‘ç»œä¸­çš„ä¸€ä¸ªè®¾å¤‡ï¼š

```go
type Node interface {
    // åŸºç¡€å±æ€§
    WithID(id string) Node
    ID() string
    Name() string
    NodeType() NodeType
    
    // VRFç®¡ç†
    GetOrCreateVrf(name string) Vrf
    GetVrf(name string) Vrf
    Vrfs() []Vrf
    
    // è·¯ç”±è¡¨ç®¡ç†
    SetIpv4RouteTable(vrfName string, table *network.AddressTable)
    SetIpv6RouteTable(vrfName string, table *network.AddressTable)
    Ipv4RouteTable(vrfName string) *network.AddressTable
    Ipv6RouteTable(vrfName string) *network.AddressTable
    
    // è·¯ç”±æŸ¥è¯¢
    IpRouteCheck(netList network.NetworkList, inPort, vrf string, af network.IPFamily) 
        (bool, *tools.Table, []string, error)
    Ipv4RouteCheck(netList network.NetworkList, inPort, vrf string) 
        (bool, *tools.Table, []string, error)
    Ipv6RouteCheck(netList network.NetworkList, inPort, vrf string) 
        (bool, *tools.Table, []string, error)
    
    // ç«¯å£ç®¡ç†
    GetPortByNameOrAlias(name string) Port
    GetPortByID(id string) Port
    AddPort(port Port, connection []*config.ConnectionInfo)
    PortList() []Port
}
```

### 3.2 DeviceNodeå®ç°

**ä½ç½®**: `pkg/nodemap/node/node.go`

DeviceNodeæ˜¯Nodeæ¥å£çš„åŸºç¡€å®ç°ï¼š

```go
type DeviceNode struct {
    id           string
    name         string
    vrfs         []api.Vrf          // VRFåˆ—è¡¨
    portRefs     []string            // ç«¯å£å¼•ç”¨åˆ—è¡¨
    portIterator api.PortIterator    // ç«¯å£è¿­ä»£å™¨
    NodeMapName  string
    cmdIp        string
    nodeType     api.NodeType
    DeviceConfig *config.DeviceConfig
}
```

### 3.3 VRFç®¡ç†æœºåˆ¶

æ¯ä¸ªNodeå¯ä»¥åŒ…å«å¤šä¸ªVRFï¼ˆVirtual Routing and Forwardingï¼‰ï¼Œæ¯ä¸ªVRFç»´æŠ¤ç‹¬ç«‹çš„è·¯ç”±è¡¨ï¼š

```go
type NodeVrf struct {
    name      string
    ipv4Table *network.AddressTable  // IPv4è·¯ç”±è¡¨
    ipv6Table *network.AddressTable  // IPv6è·¯ç”±è¡¨
}

func (n *DeviceNode) GetOrCreateVrf(name string) api.Vrf {
    for _, v := range n.vrfs {
        if v.Name() == name {
            return v
        }
    }
    // åˆ›å»ºæ–°çš„VRF
    v := &NodeVrf{name: name}
    n.vrfs = append(n.vrfs, v)
    return v
}

func (n *DeviceNode) SetIpv4RouteTable(vrfName string, table *network.AddressTable) {
    if table.Type() != network.IPv4 {
        panic(fmt.Sprintf("route table type: %s", table.Type()))
    }
    vrf := n.GetVrf(vrfName)
    if vrf != nil {
        vrf.(*NodeVrf).ipv4Table = table
    }
}
```

### 3.4 è·¯ç”±è¡¨å­˜å‚¨ç»“æ„

è·¯ç”±è¡¨ä½¿ç”¨ `network.AddressTable` å­˜å‚¨ï¼Œè¿™æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„è·¯ç”±è¡¨æ•°æ®ç»“æ„ï¼š

```go
// AddressTable æ”¯æŒï¼š
// - è·¯ç”±æ’å…¥: PushRoute(net *IPNet, nextHop *NextHop)
// - è·¯ç”±åŒ¹é…: MatchNetList(netList NetworkList, ...)
// - è·¯ç”±æŸ¥è¯¢: é€šè¿‡Matchæ–¹æ³•è·å–åŒ¹é…çš„è·¯ç”±
```

### 3.5 è·¯ç”±æŸ¥è¯¢æ ¸å¿ƒé€»è¾‘

**ä½ç½®**: `pkg/nodemap/node/node.go:IpRouteCheck`

è·¯ç”±æŸ¥è¯¢æ˜¯è·¯å¾„è®¡ç®—çš„æ ¸å¿ƒï¼Œ`IpRouteCheck` æ–¹æ³•å®ç°äº†è·¯ç”±åŒ¹é…é€»è¾‘ï¼š

```go
func (node *DeviceNode) IpRouteCheck(
    netList network.NetworkList, 
    inPort, vrf string, 
    af network.IPFamily) (bool, *tools.Table, []string, error) {
    
    // 1. è·å–å¯¹åº”VRFçš„è·¯ç”±è¡¨
    var routeTable *network.AddressTable
    if af == network.IPv4 {
        routeTable = node.Ipv4RouteTable(vrf)
    } else {
        routeTable = node.Ipv6RouteTable(vrf)
    }
    
    if routeTable == nil {
        return false, nil, nil, nil
    }
    
    // 2. åœ¨è·¯ç”±è¡¨ä¸­åŒ¹é…ç›®æ ‡ç½‘ç»œåˆ—è¡¨
    rmr := routeTable.MatchNetList(netList, true, false)
    
    // 3. æ£€æŸ¥æ˜¯å¦å®Œå…¨åŒ¹é…
    if rmr.Unmatch != nil && rmr.Unmatch.Len() > 0 {
        return false, nil, nil, nil
    }
    
    // 4. å¤„ç†å¤šè·¯å¾„æƒ…å†µï¼ˆå½“å‰ä»…æ”¯æŒå•ä¸€è·¯å¾„ï¼‰
    if rmr.Match.Len() > 1 {
        same, _ := rmr.IsSameIp()
        if !same {
            return false, nil, nil, fmt.Errorf("current not support multiple match route: %v", rmr)
        }
    }
    
    // 5. è·å–åŒ¹é…çš„è·¯ç”±è¡¨
    match, _ := rmr.Table()
    
    // 6. æå–è¾“å‡ºæ¥å£åˆ—è¡¨
    outInterfaces := match.Column("interface").List().Distinct()
    var outPortList []string
    for _, p := range outInterfaces {
        if p.(string) == inPort {
            // é˜²æ­¢è·¯ç”±å›ç¯ï¼šè¾“å…¥ç«¯å£ä¸èƒ½æ˜¯è¾“å‡ºç«¯å£
            return false, nil, nil, fmt.Errorf("node: %s, inPort %s in %+v", 
                node.Name(), inPort, outInterfaces)
        }
        outPortList = append(outPortList, p.(string))
    }
    
    return true, match, outPortList, nil
}
```

#### 3.5.1 è·¯ç”±åŒ¹é…ç®—æ³•è¯¦è§£

è·¯ç”±åŒ¹é…ä½¿ç”¨æœ€é•¿å‰ç¼€åŒ¹é…ï¼ˆLongest Prefix Matchï¼‰ç®—æ³•ï¼š

1. **ç½‘ç»œåˆ—è¡¨åŒ¹é…**: å¯¹ç›®æ ‡ç½‘ç»œåˆ—è¡¨ä¸­çš„æ¯ä¸ªç½‘ç»œï¼Œåœ¨è·¯ç”±è¡¨ä¸­æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±
2. **å‰ç¼€åŒ¹é…**: é€‰æ‹©æœ€å…·ä½“çš„è·¯ç”±ï¼ˆæœ€é•¿å‰ç¼€ï¼‰
3. **å®Œå…¨åŒ¹é…æ£€æŸ¥**: ç¡®ä¿æ‰€æœ‰ç›®æ ‡ç½‘ç»œéƒ½æœ‰å¯¹åº”çš„è·¯ç”±
4. **ä¸‹ä¸€è·³æå–**: ä»åŒ¹é…çš„è·¯ç”±ä¸­æå–ä¸‹ä¸€è·³IPå’Œè¾“å‡ºæ¥å£

### 3.6 Nodeåˆ›å»ºæµç¨‹

**ä½ç½®**: `pkg/nodemap/nodemap.go:NewNodeMapFromNetwork`

ä»Adapteråˆ›å»ºNodeçš„å®Œæ•´æµç¨‹ï¼š

```go
func NewNodeMapFromNetwork(name string, deviceList []config.DeviceConfig, force bool, task_id uint, nodeMapId *uint) (*NodeMap, context.Context) {
    // 1. åˆ›å»ºNodeMap
    nodemap := &NodeMap{
        Name:       name,
        CxMananger: &ConnectorManager{},
        taskId:     task_id,
        TNodeMapID: nodeMapId,
    }
    
    // 2. éå†æ¯ä¸ªè®¾å¤‡é…ç½®
    for index, conf := range deviceList {
        // 2.1 åˆ›å»ºAdapter
        adapter := NewAdapter(&conf)
        
        // 2.2 è·å–ç«¯å£åˆ—è¡¨
        portList := adapter.PortList(force)
        
        // 2.3 åˆ›å»ºNode
        node := NewNodeFromAdapter(adapter, name, force)
        node.WithPortIterator(nodemap)
        node.WithCmdIp(conf.Host)
        
        // 2.4 æ·»åŠ ç«¯å£åˆ°Node
        for _, port := range portList {
            uuid := uuid.New().String()
            port.WithID(uuid)
            node.AddPort(port, conf.Connection)
            nodemap.Ports = append(nodemap.Ports, port)
            port.WithNode(node)
        }
        
        // 2.5 æ·»åŠ Nodeåˆ°NodeMap
        nodemap.AddNode(node, conf.Connection)
        
        // 2.6 è·å–å¹¶è®¾ç½®è·¯ç”±è¡¨
        ipv4Tables, ipv6Tables := adapter.RouteTable(force)
        
        // 2.7 è®¾ç½®IPv4è·¯ç”±è¡¨
        for vrf, table := range ipv4Tables {
            node.GetOrCreateVrf(vrf)
            node.SetIpv4RouteTable(vrf, table)
        }
        
        // 2.8 è®¾ç½®IPv6è·¯ç”±è¡¨
        for vrf, table := range ipv6Tables {
            node.GetOrCreateVrf(vrf)
            node.SetIpv6RouteTable(vrf, table)
        }
        
        // 2.9 è®¾ç½®OutsideåŒºåŸŸå’ŒStubæ¥å£
        // ...
    }
    
    return nodemap, ctx
}
```

---

## 4. è·¯ç”±ä¸è·¯å¾„è®¡ç®—æ·±åº¦åˆ†æ

### 4.1 è·¯å¾„è®¡ç®—æ¶æ„

è·¯å¾„è®¡ç®—é‡‡ç”¨**å›¾éå†ç®—æ³•**ï¼Œé€šè¿‡é€’å½’éå†ç½‘ç»œæ‹“æ‰‘ï¼Œæ„å»ºä»æºèŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„å®Œæ•´è·¯å¾„ã€‚

**æ ¸å¿ƒç»„ä»¶**:
- **TraverseProcess**: éå†å¤„ç†å™¨ï¼Œç®¡ç†æ•´ä¸ªéå†è¿‡ç¨‹
- **TraverseNode**: éå†èŠ‚ç‚¹ï¼Œä»£è¡¨éå†è¿‡ç¨‹ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹çŠ¶æ€
- **RouteTracer**: è·¯ç”±è·Ÿè¸ªå™¨ï¼Œè®°å½•è·¯ç”±å†³ç­–è¿‡ç¨‹

### 4.2 TraverseProcessç»“æ„

**ä½ç½®**: `pkg/nodemap/traverse.go`

```go
type TraverseProcess struct {
    graph.SimpleGraph                    // å›¾ç»“æ„
    Intent         *policy.Intent        // ç­–ç•¥æ„å›¾ï¼ˆæºç½‘ç»œã€ç›®æ ‡ç½‘ç»œï¼‰
    IPFamily       network.IPFamily     // IPåè®®æ—ï¼ˆIPv4/IPv6ï¼‰
    NodeMap        *NodeMap             // ç½‘ç»œæ‹“æ‰‘
    Vrf            string               // VRFåç§°
    Gateway        string               // ç½‘å…³IP
    Area           string               // åŒºåŸŸåç§°
    TraverseOnly   bool                 // ä»…éå†æ¨¡å¼
    FuncationNodes []api.Node           // åŠŸèƒ½èŠ‚ç‚¹åˆ—è¡¨ï¼ˆé˜²ç«å¢™ã€è´Ÿè½½å‡è¡¡ï¼‰
    Results        *TraverseResult      // éå†ç»“æœ
    Vertices       map[interface{}]graph.Vertex  // å·²è®¿é—®çš„èŠ‚ç‚¹
    RouteTracer    *RouteTracer         // è·¯ç”±è·Ÿè¸ªå™¨
    logger         *zap.Logger
}
```

### 4.3 è·¯å¾„è®¡ç®—ä¸»æµç¨‹

**ä½ç½®**: `pkg/nodemap/traverse.go:Traverse`

```go
func (tp *TraverseProcess) Traverse(ctx context.Context) {
    // 1. åˆ†ç¦»æºç½‘ç»œå’Œç›®æ ‡ç½‘ç»œ
    src := tp.Intent.Src()
    var srcNetworkList, dstNetworkList *network.NetworkList
    if tp.IPFamily == network.IPv4 {
        srcNetworkList = src.IPv4()
        dstNetworkList = tp.Intent.Dst().IPv4()
    } else {
        srcNetworkList = src.IPv6()
        dstNetworkList = tp.Intent.Dst().IPv6()
    }
    
    // 2. å®šä½æºèŠ‚ç‚¹
    ok, srcNode, portNameOrMsg := tp.NodeMap.LocateNode(
        srcNetworkList, dstNetworkList, 
        tp.Intent.InputNode, 
        tp.Vrf, tp.Gateway, tp.Area)
    
    if !ok {
        tp.Results.err = model.NewProcessErr(portNameOrMsg, model.SrcNodePoositionErr)
        return
    }
    
    // 3. è·å–æºç«¯å£
    port := srcNode.GetPortByNameOrAlias(portNameOrMsg)
    
    // 4. åˆ›å»ºåˆå§‹éå†èŠ‚ç‚¹
    tn := NewTraverseNode(
        tp.NodeMap, srcNode, tp.Intent.Copy().(*policy.Intent),
        port.Vrf(), port, tp.IPFamily, "", tp, tp.TraverseOnly)
    tp.AddVertex(tn)
    tn.WithLogger(tp.logger)
    
    // 5. å¼€å§‹é€’å½’éå†
    tn.Run(tp.TraverseOnly, ctx)
}
```

### 4.4 æºèŠ‚ç‚¹å®šä½ç®—æ³•

**ä½ç½®**: `pkg/nodemap/nodemap.go:LocateNode`

æºèŠ‚ç‚¹å®šä½æ˜¯è·¯å¾„è®¡ç®—çš„èµ·ç‚¹ï¼Œç³»ç»Ÿéœ€è¦æ‰¾åˆ°æ•°æ®åŒ…çš„å…¥å£èŠ‚ç‚¹ï¼š

```go
func (nm *NodeMap) LocateNode(
    srcnetList *network.NetworkList, 
    dstnetList *network.NetworkList,
    nodeName, vrf, gw, area string) (bool, api.Node, string) {
    
    // æƒ…å†µ1: æŒ‡å®šäº†èŠ‚ç‚¹åç§°
    if nodeName != "" {
        node := nm.GetNode(nodeName)
        if area != "" {
            // é€šè¿‡åŒºåŸŸå®šä½ç«¯å£
            // ...
        } else {
            // é€šè¿‡è·¯ç”±æ£€æŸ¥å®šä½ç«¯å£
            ok, _, outPorts, err := node.IpRouteCheck(*srcnetList, "", vrf, srcnetList.Type())
            if ok && len(outPorts) == 1 {
                return true, node, outPorts[0]
            }
        }
    }
    
    // æƒ…å†µ2: é€šè¿‡ç½‘ç»œåœ°å€å®šä½
    portList := []api.Port{}
    portListMap := map[api.Port]bool{}
    for _, net := range srcnetList.List() {
        ps := nm.SelectPortListByNetwork(net, vrf)
        for _, p := range ps {
            portListMap[p] = true
        }
    }
    
    // æƒ…å†µ3: æœªæ‰¾åˆ°ï¼Œæ£€æŸ¥StubèŠ‚ç‚¹
    if len(portListMap) == 0 {
        stubOk, stubNode, stubPort := nm.LocateStubNode(srcnetList, vrf, srcnetList.Type())
        if stubOk {
            return stubOk, stubNode, stubPort.Name()
        }
        
        // æƒ…å†µ4: æ£€æŸ¥OutsideèŠ‚ç‚¹
        nodeList := nm.WhichNodeHasOutside(vrf, srcnetList.Type())
        if len(nodeList) == 1 {
            node := nodeList[0]
            var routeTable *network.AddressTable
            if srcnetList.Type() == network.IPv4 {
                routeTable = node.Ipv4RouteTable(vrf)
            } else {
                routeTable = node.Ipv6RouteTable(vrf)
            }
            ps := routeTable.OutputInterface(routeTable.DefaultGw())
            if len(ps) == 1 {
                return true, node, ps[0]
            }
        }
    }
    
    // æƒ…å†µ5: å¤šä¸ªç«¯å£ï¼Œéœ€è¦é€šè¿‡ç½‘å…³å®šä½
    if len(portList) > 1 {
        if gw == "" {
            return false, nil, "Multiple nodes, but gw is empty"
        }
        for _, port := range portList {
            if port.FullMatchByIp(gw, vrf) {
                return true, port.Node(), port.Name()
            }
        }
    }
    
    // æƒ…å†µ6: å•ä¸ªç«¯å£
    if len(portList) == 1 {
        return true, portList[0].Node(), portList[0].Name()
    }
    
    return false, nil, "can not find node, port list is empty"
}
```

### 4.5 è·¯ç”±æŸ¥è¯¢ä¸ä¸‹ä¸€è·³é€‰æ‹©

**ä½ç½®**: `pkg/nodemap/traverse.go:RunL3Route`

è¿™æ˜¯è·¯å¾„è®¡ç®—çš„æ ¸å¿ƒæ–¹æ³•ï¼Œå®ç°é€’å½’çš„è·¯ç”±æŸ¥è¯¢ï¼š

```go
func (tn *TraverseNode) RunL3Route(traverseOnly bool, ctx context.Context) (processErr model.ProcessErr) {
    // 1. æ£€æŸ¥ç¯è·¯
    if _, exists := tn.Process.Vertices[tn.Key()]; exists {
        return  // å·²è®¿é—®è¿‡ï¼Œè·³è¿‡
    }
    tn.Process.AddVertex(tn)
    
    // 2. æ‰§è¡Œè·¯ç”±æŸ¥è¯¢
    dstNetworkList := tn.Intent.Dst().NetworkList(tn.IPFamily)
    ok, hopTable, _, _ := tn.Node.IpRouteCheck(
        *dstNetworkList, 
        tn.InPort.Name(), 
        tn.InVrf, 
        tn.IPFamily)
    
    if !ok {
        return model.NewProcessErr("è·¯ç”±æŸ¥è¯¢å¤±è´¥", model.RouteQuery)
    }
    
    // 3. æ£€æŸ¥è·¯ç”±ç±»å‹
    connectedList := hopTable.Column("connected").List().Distinct()
    
    // 3.1 ç›´è¿è·¯ç”±ï¼šç›®æ ‡ç½‘ç»œç›´æ¥è¿æ¥ï¼Œè·¯å¾„ç»“æŸ
    if connectedList[0].(bool) {
        tn.Ok = true
        path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
        tn.Path += "|" + path
        return  // è·¯å¾„è®¡ç®—å®Œæˆ
    }
    
    // 3.2 éç›´è¿è·¯ç”±ï¼šéœ€è¦æŸ¥æ‰¾ä¸‹ä¸€è·³
    for it := hopTable.Iterator(); it.HasNext(); {
        _, hopMap := it.Next()
        hopIp := hopMap["ip"].(string)
        outPortName := hopMap["interface"].(string)
        outPort := tn.Node.GetPortByNameOrAlias(outPortName)
        
        // 4. é€šè¿‡ConnectoræŸ¥æ‰¾ä¸‹ä¸€è·³èŠ‚ç‚¹
        outPortConnector := tn.nm.CxMananger.GetConnectorByID(outPort.ConnectorID())
        nextDeviceNode, nextInputPort := outPortConnector.SelectNodeByIp(hopIp, outPort.Vrf())
        
        if nextDeviceNode != nil {
            // 4.1 æ‰¾åˆ°ä¸‹ä¸€è·³èŠ‚ç‚¹ï¼Œåˆ›å»ºæ–°çš„éå†èŠ‚ç‚¹
            path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
            nextNode := NewTraverseNode(
                tn.nm, nextDeviceNode, tn.Intent.Copy().(*policy.Intent),
                nextInputPort.Vrf(), nextInputPort, 
                tn.IPFamily, tn.Path+"|"+path, tn.Process, traverseOnly)
            
            // 4.2 æ£€æŸ¥æ˜¯å¦å·²è®¿é—®ï¼ˆé¿å…ç¯è·¯ï¼‰
            if _, exists := tn.Process.Vertices[nextNode.Key()]; !exists {
                tn.Process.AddVertex(nextNode)
                tn.Process.AddEdge(tn.Key(), nextNode.Key())
                // 4.3 é€’å½’å¤„ç†ä¸‹ä¸€è·³èŠ‚ç‚¹
                // æ³¨æ„ï¼šè¿™é‡Œä¸ç«‹å³è°ƒç”¨RunL3Routeï¼Œè€Œæ˜¯åœ¨å¤–éƒ¨å¾ªç¯ä¸­å¤„ç†
            }
        } else {
            // 5. æœªæ‰¾åˆ°ä¸‹ä¸€è·³èŠ‚ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦ä¸ºOutsideæˆ–Stub
            if ok, area := tn.nm.IsOutsidePort(tn.Node.Name(), outPortName, tn.IPFamily); ok {
                // 5.1 Outsideç«¯å£ï¼šæŸ¥æ‰¾åŒåŒºåŸŸçš„å…¶ä»–èŠ‚ç‚¹
                sameAreaPorts := tn.nm.GetPortsByArea(area, tn.IPFamily)
                nextNode, nextPort, foundMatch := findMatchingOutsideNode(tn.nm, sameAreaPorts, tn)
                
                if foundMatch {
                    // æ‰¾åˆ°åŒ¹é…çš„OutsideèŠ‚ç‚¹ï¼Œç»§ç»­éå†
                    // ...
                } else {
                    // æ•°æ®å·²è½¬å‘åˆ°å¤–éƒ¨ï¼Œè·¯å¾„ç»“æŸ
                    tn.Ok = true
                    tn.Path += "|Outside:" + area
                    return
                }
            } else if tn.nm.IsStubPort(tn.Node, outPort, tn.IPFamily) {
                // 5.2 Stubç«¯å£ï¼šè·¯å¾„ç»“æŸ
                tn.Ok = true
                return
            } else {
                // 5.3 é”™è¯¯ï¼šä¸‹ä¸€è·³ä¸åœ¨NodeMapä¸­
                return model.NewProcessErr("è·¯ç”±ä¸‹ä¸€è·³ä¸åœ¨NodeMapä¸­", model.NextHop_Empty)
            }
        }
    }
    
    // 6. é€’å½’å¤„ç†æ‰€æœ‰ä¸‹ä¸€è·³èŠ‚ç‚¹
    for it := tn.Iterator(); it.HasNext(); {
        _, nextNode := it.Next()
        processErr = nextNode.(*TraverseNode).Run(traverseOnly, ctx)
        if processErr.NotNil() {
            return
        }
    }
    
    return
}
```

### 4.6 è·¯å¾„ç±»å‹è¯¦è§£

ç³»ç»Ÿæ”¯æŒå¤šç§è·¯å¾„ç±»å‹ï¼š

#### 4.6.1 ç›´è¿è·¯ç”± (Connected Route)

ç›®æ ‡ç½‘ç»œç›´æ¥è¿æ¥åˆ°å½“å‰èŠ‚ç‚¹ï¼Œæ— éœ€é€šè¿‡å…¶ä»–è®¾å¤‡è½¬å‘ï¼š

```go
if connectedList[0].(bool) {
    // è·¯å¾„ç»“æŸ
    tn.Ok = true
    path := fmt.Sprintf("%s:%s", tn.InVrf, tn.Node.Name())
    tn.Path += "|" + path
    return
}
```

#### 4.6.2 ä¸‹ä¸€è·³è·¯ç”± (Next Hop Route)

ç›®æ ‡ç½‘ç»œéœ€è¦é€šè¿‡å…¶ä»–è®¾å¤‡è½¬å‘ï¼Œç³»ç»Ÿé€šè¿‡ConnectoræŸ¥æ‰¾ä¸‹ä¸€è·³èŠ‚ç‚¹ï¼š

```go
// 1. ä»è·¯ç”±è¡¨è·å–ä¸‹ä¸€è·³IPå’Œè¾“å‡ºæ¥å£
hopIp := hopMap["ip"].(string)
outPortName := hopMap["interface"].(string)

// 2. é€šè¿‡ConnectoræŸ¥æ‰¾ä¸‹ä¸€è·³èŠ‚ç‚¹
outPortConnector := tn.nm.CxMananger.GetConnectorByID(outPort.ConnectorID())
nextDeviceNode, nextInputPort := outPortConnector.SelectNodeByIp(hopIp, outPort.Vrf())
```

#### 4.6.3 Outsideè·¯ç”±

æ•°æ®åŒ…é€šè¿‡OutsideåŒºåŸŸè½¬å‘åˆ°å¤–éƒ¨ç½‘ç»œï¼š

```go
if ok, area := tn.nm.IsOutsidePort(tn.Node.Name(), outPortName, tn.IPFamily); ok {
    // æŸ¥æ‰¾åŒåŒºåŸŸçš„å…¶ä»–èŠ‚ç‚¹
    sameAreaPorts := tn.nm.GetPortsByArea(area, tn.IPFamily)
    nextNode, nextPort, foundMatch := findMatchingOutsideNode(tn.nm, sameAreaPorts, tn)
    
    if !foundMatch {
        // æ•°æ®å·²è½¬å‘åˆ°å¤–éƒ¨ï¼Œè·¯å¾„ç»“æŸ
        tn.Path += "|Outside:" + area
        return
    }
}
```

#### 4.6.4 Stubè·¯ç”±

Stubç½‘ç»œæ˜¯å•å‘ç½‘ç»œï¼Œæ•°æ®åŒ…åˆ°è¾¾Stubæ¥å£åè·¯å¾„ç»“æŸï¼š

```go
if tn.nm.IsStubPort(tn.Node, outPort, tn.IPFamily) {
    // è·¯å¾„ç»“æŸ
    tn.Ok = true
    return
}
```

### 4.7 ç¯è·¯æ£€æµ‹æœºåˆ¶

ç³»ç»Ÿé€šè¿‡å¤šç§æ–¹å¼æ£€æµ‹å’Œé¿å…è·¯ç”±ç¯è·¯ï¼š

#### 4.7.1 è·¯å¾„è®°å½•æ£€æŸ¥

```go
func (tn *TraverseNode) IsLoop() bool {
    var pathList []string
    if tn.Path != "" {
        pathList = append(pathList, strings.Split(tn.Path, "|")...)
    }
    path := tn.InVrf + ":" + tn.Node.Name()
    return tools.Contains(pathList, path)
}
```

#### 4.7.2 å·²è®¿é—®èŠ‚ç‚¹æ£€æŸ¥

```go
// æ£€æŸ¥æ˜¯å¦å·²è®¿é—®
if _, exists := tn.Process.Vertices[tn.Key()]; exists {
    return  // å·²è®¿é—®è¿‡ï¼Œè·³è¿‡
}

// æ ‡è®°ä¸ºå·²è®¿é—®
tn.Process.AddVertex(tn)
```

#### 4.7.3 è¾“å…¥ç«¯å£æ£€æŸ¥

```go
// åœ¨IpRouteCheckä¸­æ£€æŸ¥
if p.(string) == inPort {
    // è¾“å…¥ç«¯å£ä¸èƒ½æ˜¯è¾“å‡ºç«¯å£ï¼Œé˜²æ­¢ç«‹å³å›ç¯
    return false, nil, nil, fmt.Errorf("node: %s, inPort %s in %+v", 
        node.Name(), inPort, outInterfaces)
}
```

### 4.8 Connectoræœºåˆ¶

**ä½ç½®**: `pkg/nodemap/cxmananger.go`

Connectoræ˜¯è¿æ¥å™¨ï¼Œç”¨äºç®¡ç†ç«¯å£ä¹‹é—´çš„è¿æ¥å…³ç³»ï¼Œå¸®åŠ©æŸ¥æ‰¾ä¸‹ä¸€è·³èŠ‚ç‚¹ï¼š

```go
type ConnectorManager struct {
    ConnectorList []api.Connector
}

func (cx *ConnectorManager) GetOrCreateConnectorByPort(port api.Port, connections []*config.ConnectionInfo) api.Connector {
    // 1. é€šè¿‡ç«¯å£çš„IPåœ°å€æŸ¥æ‰¾ç°æœ‰Connector
    for _, ipv4 := range port.GetIpList()[network.IPv4] {
        c1 := cx.GetConnectorByIp(ipv4, vrf)
        if c1 != nil {
            return c1
        }
    }
    
    // 2. æœªæ‰¾åˆ°ï¼Œåˆ›å»ºæ–°çš„Connector
    c := cx.NewConnector(api.MP)
    return c
}
```

Connectoré€šè¿‡IPåœ°å€æŸ¥æ‰¾ä¸‹ä¸€è·³èŠ‚ç‚¹ï¼š

```go
// åœ¨TraverseNode.RunL3Routeä¸­
outPortConnector := tn.nm.CxMananger.GetConnectorByID(outPort.ConnectorID())
nextDeviceNode, nextInputPort := outPortConnector.SelectNodeByIp(hopIp, outPort.Vrf())
```

---

## 5. å…³é”®æ•°æ®ç»“æ„

### 5.1 AddressTable

**ä½ç½®**: `github.com/netxops/utils/network`

AddressTableæ˜¯è·¯ç”±è¡¨çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œæ”¯æŒé«˜æ•ˆçš„è·¯ç”±æ’å…¥å’ŒæŸ¥è¯¢ï¼š

```go
type AddressTable struct {
    // å†…éƒ¨ä½¿ç”¨Trieæ ‘æˆ–ç±»ä¼¼æ•°æ®ç»“æ„
    // æ”¯æŒï¼š
    // - PushRoute: æ’å…¥è·¯ç”±
    // - Match: åŒ¹é…å•ä¸ªç½‘ç»œ
    // - MatchNetList: åŒ¹é…ç½‘ç»œåˆ—è¡¨
    // - DefaultGw: è·å–é»˜è®¤ç½‘å…³
    // - OutputInterface: è·å–è¾“å‡ºæ¥å£
}
```

### 5.2 NextHop

NextHopè¡¨ç¤ºè·¯ç”±çš„ä¸‹ä¸€è·³ä¿¡æ¯ï¼š

```go
type NextHop struct {
    // åŒ…å«å¤šä¸ªä¸‹ä¸€è·³é€‰é¡¹ï¼ˆæ”¯æŒECMPï¼‰
    // æ¯ä¸ªé€‰é¡¹åŒ…å«ï¼š
    // - Interface: è¾“å‡ºæ¥å£
    // - NextHopIP: ä¸‹ä¸€è·³IP
    // - Connected: æ˜¯å¦ä¸ºç›´è¿è·¯ç”±
    // - DefaultGw: æ˜¯å¦ä¸ºé»˜è®¤ç½‘å…³
}
```

### 5.3 NetworkList

NetworkListè¡¨ç¤ºç½‘ç»œåœ°å€åˆ—è¡¨ï¼š

```go
type NetworkList struct {
    // åŒ…å«å¤šä¸ªç½‘ç»œåœ°å€
    // æ”¯æŒï¼š
    // - List: è·å–ç½‘ç»œåˆ—è¡¨
    // - String: è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    // - Type: è·å–IPåè®®æ—ï¼ˆIPv4/IPv6ï¼‰
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### 6.1 è·¯ç”±è¡¨ç¼“å­˜

ç³»ç»Ÿé€šè¿‡ `force` å‚æ•°æ§åˆ¶æ˜¯å¦å¼ºåˆ¶åˆ·æ–°è·¯ç”±è¡¨ï¼š

```go
func (adapter *SecPathAdapter) RouteTable(force bool) (ipv4TableMap, ipv6TableMap map[string]*network.AddressTable) {
    if !force {
        // ä½¿ç”¨ç¼“å­˜çš„è·¯ç”±è¡¨
        // ...
    }
    // å¼ºåˆ¶åˆ·æ–°è·¯ç”±è¡¨
    // ...
}
```

### 6.2 å¤šè·¯å¾„é™åˆ¶

å½“å‰ç³»ç»Ÿ**ä¸æ”¯æŒå¤šè·¯å¾„è·¯ç”±**ï¼ˆECMPï¼‰ï¼Œå¦‚æœé‡åˆ°å¤šè·¯å¾„æƒ…å†µä¼šæŠ¥é”™ï¼š

```go
if rmr.Match.Len() > 1 {
    same, _ := rmr.IsSameIp()
    if !same {
        return false, nil, nil, fmt.Errorf("current not support multiple match route: %v", rmr)
    }
}
```

### 6.3 è·¯å¾„æ„å»ºæ€§èƒ½

è·¯å¾„æ„å»ºé‡‡ç”¨é€’å½’éå†ï¼Œå¯¹äºå¤§å‹ç½‘ç»œå¯èƒ½å­˜åœ¨æ€§èƒ½é—®é¢˜ã€‚å»ºè®®ï¼š
- é™åˆ¶æœ€å¤§è·¯å¾„æ·±åº¦
- ä½¿ç”¨è¶…æ—¶æœºåˆ¶
- ä¼˜åŒ–è·¯ç”±è¡¨æŸ¥è¯¢ç®—æ³•

### 6.4 é”™è¯¯å¤„ç†

ç³»ç»Ÿå®šä¹‰äº†å¤šç§é”™è¯¯ç±»å‹ï¼š

```go
const (
    RouteQuery              = "è·¯ç”±æŸ¥è¯¢å¤±è´¥"
    RouteLoop               = "è·¯ç”±ç¯è·¯"
    NextHop_Empty           = "ä¸‹ä¸€è·³è·¯ç”±ä¸ºç©º"
    Not_Support_Multi_Route = "ä¸æ”¯æŒå¤šè·¯ç”±"
    SrcNodePoositionErr     = "æºèŠ‚ç‚¹å®šä½å¤±è´¥"
)
```

---

## 7. ä½¿ç”¨ç¤ºä¾‹

### 7.1 åŸºæœ¬è·¯å¾„è®¡ç®—

```go
// 1. åˆ›å»ºç½‘ç»œæ‹“æ‰‘
nodeMap, ctx := NewNodeMapFromNetwork("test-network", deviceList, false, 1, nil)

// 2. åˆ›å»ºç­–ç•¥æ„å›¾
intent := &policy.Intent{
    PolicyEntry: *policyEntry,
    // ...
}

// 3. æ‰§è¡Œè·¯å¾„è®¡ç®—
tp := nodeMap.MakeTemplates(intent, ctx)

// 4. è·å–è·¯å¾„ç»“æœ
for _, item := range tp.Results.Items {
    fmt.Printf("èŠ‚ç‚¹: %s\n", item.Node.Name())
    // éå†è·¯å¾„...
}
```

### 7.2 è·¯ç”±æŸ¥è¯¢ç¤ºä¾‹

```go
// åœ¨Nodeä¸­æŸ¥è¯¢è·¯ç”±
dstNetList := network.NewNetworkList()
dstNetList.Add(network.ParseIPNet("10.0.0.0/8"))

ok, hopTable, outPorts, err := node.IpRouteCheck(
    *dstNetList, 
    "GigabitEthernet0/0", 
    "default", 
    network.IPv4)

if ok {
    fmt.Printf("æ‰¾åˆ°è·¯ç”±ï¼Œè¾“å‡ºæ¥å£: %v\n", outPorts)
    // å¤„ç†hopTable...
}
```

---

## 8. æ€»ç»“

### 8.1 æ ¸å¿ƒæœºåˆ¶æ€»ç»“

1. **Adapterå±‚**: è´Ÿè´£ä»è®¾å¤‡è·å–è·¯ç”±è¡¨å’Œç«¯å£ä¿¡æ¯ï¼Œæ”¯æŒå¤šç§è®¾å¤‡ç±»å‹
2. **Nodeå±‚**: ç®¡ç†è®¾å¤‡çš„è·¯ç”±è¡¨å’Œç«¯å£ï¼Œæä¾›è·¯ç”±æŸ¥è¯¢æ¥å£
3. **è·¯å¾„è®¡ç®—**: é€šè¿‡é€’å½’éå†å’Œè·¯ç”±æŸ¥è¯¢ï¼Œæ„å»ºä»æºåˆ°ç›®æ ‡çš„å®Œæ•´è·¯å¾„

### 8.2 å…³é”®ç‰¹æ€§

- âœ… æ”¯æŒå¤šVRF
- âœ… æ”¯æŒIPv4/IPv6
- âœ… æ”¯æŒç›´è¿ã€ä¸‹ä¸€è·³ã€Outsideã€Stubç­‰å¤šç§è·¯å¾„ç±»å‹
- âœ… ç¯è·¯æ£€æµ‹æœºåˆ¶
- âœ… è·¯ç”±è·Ÿè¸ªå’Œæ—¥å¿—è®°å½•

### 8.3 é™åˆ¶ä¸æ”¹è¿›æ–¹å‘

- âŒ ä¸æ”¯æŒå¤šè·¯å¾„è·¯ç”±ï¼ˆECMPï¼‰
- âŒ è·¯å¾„è®¡ç®—æ€§èƒ½å¯èƒ½å—ç½‘ç»œè§„æ¨¡å½±å“
- ğŸ”„ å¯è€ƒè™‘å¢åŠ è·¯å¾„æƒé‡å’Œè´Ÿè½½å‡è¡¡æ”¯æŒ
- ğŸ”„ å¯ä¼˜åŒ–è·¯ç”±è¡¨æŸ¥è¯¢ç®—æ³•ï¼Œæå‡æ€§èƒ½

---

## é™„å½•

### A. ä»£ç ä½ç½®ç´¢å¼•

| åŠŸèƒ½æ¨¡å— | æ–‡ä»¶è·¯å¾„ | å…³é”®å‡½æ•° |
|---------|---------|---------|
| Adapterå·¥å‚ | `pkg/nodemap/factory.go` | `NewAdapter` |
| Nodeåˆ›å»º | `pkg/nodemap/nodemap.go` | `NewNodeMapFromNetwork` |
| è·¯ç”±æŸ¥è¯¢ | `pkg/nodemap/node/node.go` | `IpRouteCheck` |
| è·¯å¾„è®¡ç®— | `pkg/nodemap/traverse.go` | `Traverse`, `RunL3Route` |
| æºèŠ‚ç‚¹å®šä½ | `pkg/nodemap/nodemap.go` | `LocateNode` |
| Connectorç®¡ç† | `pkg/nodemap/cxmananger.go` | `GetOrCreateConnectorByPort` |

### B. ç›¸å…³ä¾èµ–

- `github.com/netxops/utils/network`: ç½‘ç»œå·¥å…·åº“ï¼ˆAddressTableç­‰ï¼‰
- `github.com/netxops/utils/graph`: å›¾ç®—æ³•åº“
- `github.com/netxops/utils/policy`: ç­–ç•¥å·¥å…·åº“

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-01-XX  
**ä½œè€…**: AI Assistant

