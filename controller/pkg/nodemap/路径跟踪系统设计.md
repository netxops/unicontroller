# 路径跟踪系统设计

## 1. 问题分析

### 1.1 当前系统的局限性

当前系统在路径跟踪方面存在以下问题：

1. **单一路径表示**
   - `TraverseNode.Path` 只是一个字符串，无法区分多条路径
   - 当遇到ECMP时，无法为每条路径维护独立状态

2. **节点访问跟踪不足**
   - `TraverseProcess.Vertices` 只记录节点是否访问过
   - 无法区分"通过不同路径访问同一节点"的情况
   - 无法跟踪"同一节点在不同路径上的处理结果"

3. **结果合并缺失**
   - `TraverseResult.Items` 按节点存储结果
   - 当多条路径经过同一节点时，无法正确合并结果
   - 可能导致重复配置或结果丢失

4. **路径状态管理缺失**
   - 无法跟踪每条路径的状态（进行中、成功、失败）
   - 无法处理部分路径失败的情况
   - 无法统计路径数量和成功率

### 1.2 多路径场景的挑战

当遇到ECMP时，系统需要：

```
节点A
  ├─> 路径1 -> 节点B -> 节点D (成功)
  ├─> 路径2 -> 节点C -> 节点D (成功)
  └─> 路径3 -> 节点E -> 节点F (失败)
```

系统需要能够：
- 跟踪3条独立的路径
- 为每条路径维护独立的状态
- 合并节点D的结果（路径1和路径2都经过节点D）
- 记录路径3的失败原因

---

## 2. 路径跟踪系统设计

### 2.1 核心数据结构

#### 2.1.1 路径标识

```go
// PathID 路径唯一标识
type PathID string

// 生成路径ID
func GeneratePathID(parentPathID PathID, nodeName, vrf, inPort, outPort string) PathID {
    if parentPathID == "" {
        // 根路径
        return PathID(fmt.Sprintf("path_%s_%s_%s", vrf, nodeName, inPort))
    }
    // 子路径（从父路径分支）
    return PathID(fmt.Sprintf("%s->%s:%s:%s->%s", 
        parentPathID, vrf, nodeName, inPort, outPort))
}
```

#### 2.1.2 路径状态

```go
// PathState 路径状态
type PathState int

const (
    PathStatePending   PathState = iota // 待处理
    PathStateRunning                    // 处理中
    PathStateSuccess                    // 成功
    PathStateFailed                     // 失败
    PathStateMerged                     // 已合并（与其他路径合并）
)

func (ps PathState) String() string {
    switch ps {
    case PathStatePending:
        return "pending"
    case PathStateRunning:
        return "running"
    case PathStateSuccess:
        return "success"
    case PathStateFailed:
        return "failed"
    case PathStateMerged:
        return "merged"
    default:
        return "unknown"
    }
}
```

#### 2.1.3 路径跟踪器

```go
// PathTracker 路径跟踪器 - 核心组件
type PathTracker struct {
    mu sync.RWMutex
    
    // 路径管理
    paths map[PathID]*PathStateInfo  // 所有路径的状态
    
    // 节点路径映射：记录每个节点被哪些路径访问
    nodePaths map[string]map[PathID]bool  // nodeKey -> pathIDs
    
    // 路径节点映射：记录每条路径经过的节点
    pathNodes map[PathID][]string  // pathID -> nodeKeys
    
    // 路径结果映射：记录每条路径上每个节点的处理结果
    pathResults map[PathID]map[string]*NodePathResult  // pathID -> nodeKey -> result
    
    // 路径关系：记录路径的分支和合并关系
    pathRelations map[PathID]*PathRelation  // pathID -> relation
    
    // 统计信息
    stats *PathTrackerStats
}

// PathStateInfo 路径状态信息
type PathStateInfo struct {
    PathID       PathID
    State        PathState
    ParentPathID PathID      // 父路径ID（如果是从父路径分支）
    BranchIndex  int         // 分支索引（同一节点的多个分支）
    StartTime    time.Time
    EndTime      time.Time
    Error        model.ProcessErr
    NodeCount    int         // 路径上的节点数量
    IsECMP       bool        // 是否为ECMP路径
}

// PathRelation 路径关系
type PathRelation struct {
    ParentPathID PathID   // 父路径
    ChildPathIDs []PathID // 子路径（分支）
    MergePathID  PathID   // 合并到的路径（如果与其他路径合并）
}

// NodePathResult 节点在特定路径上的处理结果
type NodePathResult struct {
    NodeKey      string
    PathID       PathID
    Result       *TraverseResultItem
    ProcessTime  time.Time
    IsMerged     bool  // 是否已与其他路径的结果合并
}

// PathTrackerStats 路径跟踪统计
type PathTrackerStats struct {
    TotalPaths      int
    SuccessPaths    int
    FailedPaths     int
    ECMPPaths       int
    MergedNodes     int  // 合并的节点数量
    MaxPathDepth    int  // 最大路径深度
    AvgPathLength   float64  // 平均路径长度
}
```

#### 2.1.4 扩展 TraverseProcess

```go
type TraverseProcess struct {
    graph.SimpleGraph
    Intent         *policy.Intent
    IPFamily       network.IPFamily
    NodeMap        *NodeMap
    Vrf            string
    Gateway        string
    Area           string
    TraverseOnly   bool
    FuncationNodes []api.Node
    Results        *TraverseResult
    logger         *zap.Logger
    Vertices       map[interface{}]graph.Vertex
    RouteTracer    *RouteTracer
    
    // ========== 新增：路径跟踪系统 ==========
    PathTracker    *PathTracker  // 路径跟踪器
    EnableMultiPath bool          // 是否启用多路径支持
    MaxPaths        int           // 最大路径数量限制
}
```

#### 2.1.5 扩展 TraverseNode

```go
type TraverseNode struct {
    nm     *NodeMap
    Node   api.Node
    Intent *policy.Intent
    InVrf  string
    InPort api.Port
    Neighbor map[interface{}]graph.Vertex
    IPFamily network.IPFamily
    Path     string  // 保留用于兼容性
    Ok       bool
    Info     string
    Process  *TraverseProcess
    TraverseOnly bool
    logger *zap.Logger
    
    // ========== 新增：路径跟踪相关 ==========
    PathID       PathID      // 当前路径ID
    ParentPathID PathID      // 父路径ID
    BranchIndex  int         // 分支索引（同一节点的多个分支）
    IsECMP       bool        // 是否为ECMP路径
    NodeKey      string      // 节点唯一键（用于路径跟踪）
}
```

---

## 3. 路径跟踪系统实现

### 3.1 路径跟踪器核心方法

```go
// NewPathTracker 创建路径跟踪器
func NewPathTracker() *PathTracker {
    return &PathTracker{
        paths:        make(map[PathID]*PathStateInfo),
        nodePaths:    make(map[string]map[PathID]bool),
        pathNodes:    make(map[PathID][]string),
        pathResults:  make(map[PathID]map[string]*NodePathResult),
        pathRelations: make(map[PathID]*PathRelation),
        stats:        &PathTrackerStats{},
    }
}

// StartPath 开始跟踪一条新路径
func (pt *PathTracker) StartPath(pathID PathID, parentPathID PathID, isECMP bool) {
    pt.mu.Lock()
    defer pt.mu.Unlock()
    
    pt.paths[pathID] = &PathStateInfo{
        PathID:       pathID,
        State:        PathStateRunning,
        ParentPathID: parentPathID,
        StartTime:    time.Now(),
        IsECMP:       isECMP,
    }
    
    pt.pathNodes[pathID] = []string{}
    pt.pathResults[pathID] = make(map[string]*NodePathResult)
    
    if parentPathID != "" {
        // 记录路径关系
        if pt.pathRelations[parentPathID] == nil {
            pt.pathRelations[parentPathID] = &PathRelation{
                ParentPathID: parentPathID,
                ChildPathIDs: []PathID{},
            }
        }
        pt.pathRelations[parentPathID].ChildPathIDs = append(
            pt.pathRelations[parentPathID].ChildPathIDs, pathID)
    }
    
    pt.stats.TotalPaths++
    if isECMP {
        pt.stats.ECMPPaths++
    }
}

// AddNodeToPath 将节点添加到路径
func (pt *PathTracker) AddNodeToPath(pathID PathID, nodeKey string) {
    pt.mu.Lock()
    defer pt.mu.Unlock()
    
    // 添加到路径节点列表
    if pt.pathNodes[pathID] == nil {
        pt.pathNodes[pathID] = []string{}
    }
    pt.pathNodes[pathID] = append(pt.pathNodes[pathID], nodeKey)
    
    // 更新节点路径映射
    if pt.nodePaths[nodeKey] == nil {
        pt.nodePaths[nodeKey] = make(map[PathID]bool)
    }
    pt.nodePaths[nodeKey][pathID] = true
    
    // 更新路径节点计数
    if pathInfo, exists := pt.paths[pathID]; exists {
        pathInfo.NodeCount = len(pt.pathNodes[pathID])
    }
}

// AddNodeResult 添加节点处理结果
func (pt *PathTracker) AddNodeResult(pathID PathID, nodeKey string, result *TraverseResultItem) {
    pt.mu.Lock()
    defer pt.mu.Unlock()
    
    if pt.pathResults[pathID] == nil {
        pt.pathResults[pathID] = make(map[string]*NodePathResult)
    }
    
    pt.pathResults[pathID][nodeKey] = &NodePathResult{
        NodeKey:     nodeKey,
        PathID:      pathID,
        Result:      result,
        ProcessTime: time.Now(),
        IsMerged:    false,
    }
}

// CompletePath 完成路径（成功或失败）
func (pt *PathTracker) CompletePath(pathID PathID, success bool, err model.ProcessErr) {
    pt.mu.Lock()
    defer pt.mu.Unlock()
    
    if pathInfo, exists := pt.paths[pathID]; exists {
        pathInfo.EndTime = time.Now()
        if success {
            pathInfo.State = PathStateSuccess
            pt.stats.SuccessPaths++
        } else {
            pathInfo.State = PathStateFailed
            pathInfo.Error = err
            pt.stats.FailedPaths++
        }
    }
}

// CheckNodeVisited 检查节点是否在特定路径上已访问
func (pt *PathTracker) CheckNodeVisited(pathID PathID, nodeKey string) bool {
    pt.mu.RLock()
    defer pt.mu.RUnlock()
    
    // 检查节点是否在当前路径上
    if nodes, exists := pt.pathNodes[pathID]; exists {
        return tools.Contains(nodes, nodeKey)
    }
    return false
}

// GetNodePaths 获取访问过节点的所有路径
func (pt *PathTracker) GetNodePaths(nodeKey string) []PathID {
    pt.mu.RLock()
    defer pt.mu.RUnlock()
    
    if paths, exists := pt.nodePaths[nodeKey]; exists {
        result := make([]PathID, 0, len(paths))
        for pathID := range paths {
            result = append(result, pathID)
        }
        return result
    }
    return []PathID{}
}

// MergeNodeResults 合并节点在不同路径上的结果
func (pt *PathTracker) MergeNodeResults(nodeKey string) *TraverseResultItem {
    pt.mu.Lock()
    defer pt.mu.Unlock()
    
    // 获取访问过该节点的所有路径
    pathIDs := pt.GetNodePaths(nodeKey)
    if len(pathIDs) == 0 {
        return nil
    }
    
    if len(pathIDs) == 1 {
        // 只有一条路径，直接返回
        if results, exists := pt.pathResults[pathIDs[0]]; exists {
            if result, exists := results[nodeKey]; exists {
                return result.Result
            }
        }
        return nil
    }
    
    // 多条路径：合并结果
    // 策略：合并配置命令，去重
    mergedResult := &TraverseResultItem{
        Node:        nil,  // 从第一个结果获取
        StepProcess: nil,
        CmdListList: []interface{}{},
        AdditionCli: []string{},
    }
    
    seenCommands := make(map[string]bool)
    
    for _, pathID := range pathIDs {
        if results, exists := pt.pathResults[pathID]; exists {
            if result, exists := results[nodeKey]; exists && result.Result != nil {
                if mergedResult.Node == nil {
                    mergedResult.Node = result.Result.Node
                    mergedResult.StepProcess = result.Result.StepProcess
                }
                
                // 合并命令列表（去重）
                for _, cmd := range result.Result.CmdListList {
                    cmdKey := fmt.Sprintf("%v", cmd)
                    if !seenCommands[cmdKey] {
                        mergedResult.CmdListList = append(mergedResult.CmdListList, cmd)
                        seenCommands[cmdKey] = true
                    }
                }
                
                // 合并附加命令（去重）
                for _, cli := range result.Result.AdditionCli {
                    if !seenCommands[cli] {
                        mergedResult.AdditionCli = append(mergedResult.AdditionCli, cli)
                        seenCommands[cli] = true
                    }
                }
                
                // 标记为已合并
                result.IsMerged = true
            }
        }
    }
    
    pt.stats.MergedNodes++
    return mergedResult
}

// GetPathStats 获取路径统计信息
func (pt *PathTracker) GetPathStats() *PathTrackerStats {
    pt.mu.RLock()
    defer pt.mu.RUnlock()
    
    // 计算平均路径长度
    totalLength := 0
    for _, nodes := range pt.pathNodes {
        totalLength += len(nodes)
    }
    if pt.stats.TotalPaths > 0 {
        pt.stats.AvgPathLength = float64(totalLength) / float64(pt.stats.TotalPaths)
    }
    
    // 计算最大路径深度
    maxDepth := 0
    for _, nodes := range pt.pathNodes {
        if len(nodes) > maxDepth {
            maxDepth = len(nodes)
        }
    }
    pt.stats.MaxPathDepth = maxDepth
    
    return pt.stats
}
```

### 3.2 修改 TraverseNode 使用路径跟踪

```go
// NewTraverseNode 创建遍历节点（支持路径跟踪）
func NewTraverseNodeWithPath(
    nm *NodeMap,
    n api.Node,
    intent *policy.Intent,
    inVrf string,
    inPort api.Port,
    ipFamily network.IPFamily,
    pathID PathID,
    parentPathID PathID,
    branchIndex int,
    process *TraverseProcess,
    traverseOnly bool) *TraverseNode {
    
    nodeKey := fmt.Sprintf("%s:%s:%s", inVrf, n.Name(), inPort.Name())
    
    tn := &TraverseNode{
        nm:           nm,
        Node:         n,
        Intent:       intent,
        InVrf:        inVrf,
        InPort:       inPort,
        IPFamily:     ipFamily,
        Path:         "",  // 保留用于兼容性
        Neighbor:     map[interface{}]graph.Vertex{},
        Process:      process,
        TraverseOnly: traverseOnly,
        PathID:       pathID,
        ParentPathID: parentPathID,
        BranchIndex:  branchIndex,
        NodeKey:      nodeKey,
    }
    
    // 如果启用了路径跟踪，注册节点到路径
    if process.PathTracker != nil && pathID != "" {
        process.PathTracker.AddNodeToPath(pathID, nodeKey)
    }
    
    return tn
}

// Key 生成节点唯一键（用于路径跟踪）
func (tn *TraverseNode) Key() interface{} {
    if tn.NodeKey != "" {
        return tn.NodeKey
    }
    // 兼容旧代码
    return fmt.Sprintf("%s:%s:%s", tn.InVrf, tn.Node.Name(), tn.InPort.Name())
}
```

### 3.3 修改 RunL3Route 支持多路径跟踪

```go
func (tn *TraverseNode) RunL3Route(traverseOnly bool, ctx context.Context) (processErr model.ProcessErr) {
    // ... 前面的检查逻辑 ...
    
    // 执行路由查询
    ok, hopTable, _, _ := tn.Node.IpRouteCheck(*dstNetworkList, tn.InPort.Name(), tn.InVrf, tn.IPFamily)
    
    if !ok {
        // 路径失败
        if tn.Process.PathTracker != nil && tn.PathID != "" {
            tn.Process.PathTracker.CompletePath(tn.PathID, false, 
                model.NewProcessErr("路由查询失败", model.RouteQuery))
        }
        return model.NewProcessErr("路由查询失败", model.RouteQuery)
    }
    
    // 检查直连路由
    connectedList := hopTable.Column("connected").List().Distinct()
    if len(connectedList) > 0 && connectedList[0].(bool) {
        // 路径成功
        if tn.Process.PathTracker != nil && tn.PathID != "" {
            tn.Process.PathTracker.CompletePath(tn.PathID, true, model.ProcessErr{})
        }
        tn.Ok = true
        return
    }
    
    // 收集所有可能的下一跳
    var nextHops []*NextHopInfo
    for it := hopTable.Iterator(); it.HasNext(); {
        _, hopMap := it.Next()
        // ... 收集下一跳 ...
    }
    
    if len(nextHops) == 0 {
        // 路径失败
        if tn.Process.PathTracker != nil && tn.PathID != "" {
            tn.Process.PathTracker.CompletePath(tn.PathID, false,
                model.NewProcessErr("未找到下一跳", model.NextHop_Empty))
        }
        return model.NewProcessErr("未找到下一跳", model.NextHop_Empty)
    }
    
    // ========== 关键：多路径处理 ==========
    if len(nextHops) == 1 {
        // 单一路径：保持原有逻辑
        nh := nextHops[0]
        nextPathID := tn.PathID  // 继续使用当前路径ID
        nextNode := NewTraverseNodeWithPath(
            tn.nm, nh.NextNode, tn.Intent.Copy().(*policy.Intent),
            nh.NextInputPort.Vrf(), nh.NextInputPort,
            tn.IPFamily, nextPathID, tn.PathID, 0, tn.Process, traverseOnly)
        // ... 处理单一路径 ...
    } else {
        // ========== 多路径：为每个下一跳创建独立路径 ==========
        isECMP := true
        
        for i, nh := range nextHops {
            // 为每个分支创建新的路径ID
            branchPathID := GeneratePathID(tn.PathID, 
                nh.NextNode.Name(), 
                nh.NextInputPort.Vrf(),
                nh.NextInputPort.Name(),
                nh.OutPortName)
            
            // 启动新路径跟踪
            if tn.Process.PathTracker != nil {
                tn.Process.PathTracker.StartPath(branchPathID, tn.PathID, isECMP)
            }
            
            // 创建新的遍历节点
            nextNode := NewTraverseNodeWithPath(
                tn.nm, nh.NextNode, tn.Intent.Copy().(*policy.Intent),
                nh.NextInputPort.Vrf(), nh.NextInputPort,
                tn.IPFamily, branchPathID, tn.PathID, i, tn.Process, traverseOnly)
            nextNode.IsECMP = true
            nextNode.WithLogger(tn.logger)
            
            // 检查路径限制
            if tn.Process.MaxPaths > 0 {
                stats := tn.Process.PathTracker.GetPathStats()
                if stats.TotalPaths > tn.Process.MaxPaths {
                    tn.logger.Warn("达到最大路径数限制，跳过剩余路径",
                        zap.Int("当前路径数", stats.TotalPaths),
                        zap.Int("最大路径数", tn.Process.MaxPaths))
                    continue
                }
            }
            
            // 检查节点是否在当前路径上已访问（避免环路）
            nodeKey := nextNode.NodeKey
            if tn.Process.PathTracker != nil {
                if tn.Process.PathTracker.CheckNodeVisited(branchPathID, nodeKey) {
                    tn.logger.Info("节点在当前路径上已访问，跳过以避免环路",
                        zap.String("节点", nodeKey),
                        zap.String("路径", string(branchPathID)))
                    continue
                }
            }
            
            // 添加到图结构
            if _, exists := tn.Process.Vertices[nextNode.Key()]; !exists {
                tn.Process.AddVertex(nextNode)
                tn.Process.AddEdge(tn.Key(), nextNode.Key())
            }
            
            // 递归处理每个分支
            branchErr := nextNode.Run(traverseOnly, ctx)
            if branchErr.NotNil() {
                // 记录分支错误，但继续处理其他分支
                if tn.Process.PathTracker != nil {
                    tn.Process.PathTracker.CompletePath(branchPathID, false, branchErr)
                }
                tn.logger.Warn("ECMP路径分支处理失败",
                    zap.Int("分支索引", i),
                    zap.String("路径", string(branchPathID)),
                    zap.String("错误", branchErr.GetDesc()))
            }
        }
    }
    
    return
}
```

### 3.4 结果合并机制

```go
// CollectResults 收集所有路径的结果并合并
func (tp *TraverseProcess) CollectResults() {
    if tp.PathTracker == nil {
        return
    }
    
    // 获取所有节点
    allNodes := make(map[string]bool)
    for _, vertex := range tp.Vertices {
        tn := vertex.(*TraverseNode)
        allNodes[tn.NodeKey] = true
    }
    
    // 为每个节点合并结果
    for nodeKey := range allNodes {
        // 获取访问过该节点的所有路径
        pathIDs := tp.PathTracker.GetNodePaths(nodeKey)
        if len(pathIDs) == 0 {
            continue
        }
        
        if len(pathIDs) == 1 {
            // 只有一条路径，直接使用结果
            pathID := pathIDs[0]
            if results, exists := tp.PathTracker.pathResults[pathID]; exists {
                if result, exists := results[nodeKey]; exists && result.Result != nil {
                    tp.Results.Items = append(tp.Results.Items, result.Result)
                }
            }
        } else {
            // 多条路径：合并结果
            mergedResult := tp.PathTracker.MergeNodeResults(nodeKey)
            if mergedResult != nil {
                tp.Results.Items = append(tp.Results.Items, mergedResult)
            }
        }
    }
}
```

---

## 4. 使用示例

### 4.1 启用路径跟踪

```go
// 创建TraverseProcess时启用路径跟踪
tp := &TraverseProcess{
    // ... 其他字段 ...
    PathTracker:    NewPathTracker(),
    EnableMultiPath: true,
    MaxPaths:       100,  // 限制最大路径数
}

// 创建初始路径
rootPathID := GeneratePathID("", srcNode.Name(), vrf, portName, "")
tp.PathTracker.StartPath(rootPathID, "", false)

// 创建初始节点
tn := NewTraverseNodeWithPath(
    nm, srcNode, intent, vrf, port, ipFamily,
    rootPathID, "", 0, tp, traverseOnly)
```

### 4.2 获取路径统计

```go
// 遍历完成后获取统计信息
stats := tp.PathTracker.GetPathStats()
fmt.Printf("总路径数: %d\n", stats.TotalPaths)
fmt.Printf("成功路径: %d\n", stats.SuccessPaths)
fmt.Printf("失败路径: %d\n", stats.FailedPaths)
fmt.Printf("ECMP路径: %d\n", stats.ECMPPaths)
fmt.Printf("合并节点: %d\n", stats.MergedNodes)
fmt.Printf("平均路径长度: %.2f\n", stats.AvgPathLength)
```

### 4.3 查询路径信息

```go
// 查询访问过特定节点的所有路径
pathIDs := tp.PathTracker.GetNodePaths("default:NodeA:GigabitEthernet0/0")
for _, pathID := range pathIDs {
    pathInfo := tp.PathTracker.paths[pathID]
    fmt.Printf("路径 %s: 状态=%s, 节点数=%d\n", 
        pathID, pathInfo.State, pathInfo.NodeCount)
}
```

---

## 5. 总结

路径跟踪系统解决了多路径支持的核心问题：

1. ✅ **路径状态管理**: 为每条路径维护独立的状态
2. ✅ **节点路径映射**: 跟踪节点与路径的关系
3. ✅ **结果合并**: 正确合并相同节点在不同路径上的结果
4. ✅ **路径统计**: 提供路径统计和分析能力
5. ✅ **环路检测**: 基于路径的环路检测（而不是全局节点访问）

这个系统为多路径支持提供了坚实的基础。

---

**文档版本**: v1.0  
**最后更新**: 2025-01-XX

