# 厂商和平台自动检测实施指南

## 一、概述

本文档说明如何将自动检测机制集成到现有系统中，实现设备厂商和平台的自动识别。

## 二、架构设计

### 2.1 检测流程

```
设备请求（IP + 凭证）
    ↓
[阶段1] 连接检测
    ├─ 检测SNMP可达性
    ├─ 检测SSH可达性
    └─ 检测TELNET可达性
    ↓
[阶段2] 信息采集
    ├─ SNMP: sysDescr, sysName
    ├─ SSH: show version / cat /etc/os-release
    └─ TELNET: show version (备选)
    ↓
[阶段3] 规则匹配
    ├─ 厂商识别（manufacturer_rules.yaml）
    ├─ 平台识别（platform_rules.yaml）
    └─ 版本提取（version_rules.yaml）
    ↓
[阶段4] 配置匹配
    ├─ 精确匹配（manufacturer/platform/version）
    ├─ 平台匹配（manufacturer/platform）
    ├─ 厂商匹配（manufacturer/default）
    └─ 分类匹配（catalog/default）
    ↓
[阶段5] 结果返回
    └─ DetectionResult {
         Manufacturer, Platform, Version,
         Catalog, Confidence, DeviceConfig
       }
```

### 2.2 关键组件

1. **DeviceDetector**: 检测服务主类
2. **RuleLoader**: 规则加载器
3. **ConfigMatcher**: 配置匹配器
4. **DetectionCache**: 检测结果缓存

## 三、实施步骤

### 步骤1: 创建检测服务包

```bash
mkdir -p pkg/detector
```

创建以下文件：
- `pkg/detector/detector.go` - 检测服务主类
- `pkg/detector/rule_loader.go` - 规则加载器
- `pkg/detector/config_matcher.go` - 配置匹配器
- `pkg/detector/cache.go` - 结果缓存
- `pkg/detector/types.go` - 类型定义

### 步骤2: 实现检测服务

参考 `自动检测机制设计方案.md` 中的代码示例实现各个组件。

### 步骤3: 集成到API

在 `pkg/controller/api/api.go` 中添加：

```go
// 检测设备接口
func (ap *ControllerAPI) DetectDevice(w http.ResponseWriter, r *http.Request) {
    var request struct {
        IP            string
        SNMPCommunity string
        SSHCredentials *structs.SSHCredentials
    }
    
    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    detector := detector.NewDeviceDetector(
        ap.controller.ConfigManager.Config.BaseConfig.PipelineTemplates,
    )
    
    result, err := detector.Detect(&detector.DetectionRequest{
        IP:            request.IP,
        SNMPCommunity: request.SNMPCommunity,
        SSHCredentials: request.SSHCredentials,
    })
    
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(result)
}
```

### 步骤4: 自动检测集成

在创建设备时，如果manufacturer/platform为空，自动触发检测：

```go
func (ap *ControllerAPI) createDevice(request *DeviceRequest) (*netdevice.BaseNetworkDevice, error) {
    // 自动检测逻辑
    if request.RemoteInfo.Manufacturer == "" || request.RemoteInfo.Platform == "" {
        detector := detector.NewDeviceDetector(
            ap.controller.ConfigManager.Config.BaseConfig.PipelineTemplates,
        )
        
        detectionResult, err := detector.Detect(&detector.DetectionRequest{
            IP:            request.RemoteInfo.Ip,
            SNMPCommunity: request.RemoteInfo.Community[0],
            SSHCredentials: &structs.SSHCredentials{
                Username: request.RemoteInfo.Username,
                Password: request.RemoteInfo.Password,
            },
        })
        
        if err == nil {
            // 更新请求信息
            request.RemoteInfo.Manufacturer = detectionResult.Manufacturer
            request.RemoteInfo.Platform = detectionResult.Platform
            if detectionResult.Version != "" {
                request.RemoteInfo.Meta.Version = detectionResult.Version
            }
            
            // 如果检测到了配置，直接使用
            if detectionResult.DeviceConfig != nil {
                modeConfig, hubConfig := ap.extractConfigsFromDeviceConfig(
                    detectionResult.DeviceConfig,
                )
                return netdevice.NewBaseNetworkDevice(
                    baseInfo, modeConfig, hubConfig, logger,
                )
            }
        } else {
            log.Printf("Auto-detection failed: %v, using default config", err)
        }
    }
    
    // 继续原有流程...
}
```

### 步骤5: 添加路由

在路由配置中添加检测接口：

```go
// 设备检测接口
router.POST("/api/v1/device/detect", ap.DetectDevice)
```

## 四、使用示例

### 4.1 API调用示例

```bash
# 检测设备
curl -X POST http://localhost:8080/api/v1/device/detect \
  -H "Content-Type: application/json" \
  -d '{
    "ip": "192.168.1.1",
    "snmp_community": "public",
    "ssh_credentials": {
      "username": "admin",
      "password": "password"
    }
  }'
```

### 4.2 响应示例

```json
{
  "manufacturer": "Cisco",
  "platform": "IOS",
  "version": "15.0",
  "catalog": "NETWORK",
  "confidence": 0.95,
  "device_config": {
    "vendor": "Cisco",
    "platform": "IOS",
    "version": "15.0",
    "pipeline": [...]
  },
  "errors": []
}
```

### 4.3 自动检测使用

在创建设备时，只需提供IP和凭证，系统会自动检测：

```json
{
  "ip": "192.168.1.1",
  "community": ["public"],
  "username": "admin",
  "password": "password"
  // manufacturer 和 platform 可以不提供，系统会自动检测
}
```

## 五、配置规则维护

### 5.1 添加新设备类型

1. **添加厂商规则** (`detect/rules/manufacturer_rules.yaml`):
```yaml
- name: new_vendor_snmp
  manufacturer: NewVendor
  catalog: NETWORK
  priority: 10
  patterns:
    - source: sysDescr
      regex: "(?i)newvendor"
      confidence: 0.9
      required: true
```

2. **添加平台规则** (`detect/rules/platform_rules.yaml`):
```yaml
- name: new_vendor_platform_snmp
  manufacturer: NewVendor
  platform: NewPlatform
  catalog: NETWORK
  priority: 20
  patterns:
    - source: sysDescr
      regex: "(?i)newvendor.*newplatform"
      confidence: 0.9
      required: true
```

3. **创建设备配置目录**:
```bash
mkdir -p deploy/templates/newvendor/newplatform
# 创建 config.yaml 等配置文件
```

### 5.2 优化检测规则

1. **提高置信度**: 使用更精确的正则表达式
2. **添加必需条件**: 标记关键特征为 `required: true`
3. **调整优先级**: 更具体的规则使用更高的优先级

## 六、性能优化

### 6.1 结果缓存

检测结果会被缓存，避免重复检测：

```go
// 缓存TTL: 1小时
cache := detector.NewDetectionCache(1 * time.Hour)
```

### 6.2 并发检测

支持并发检测多个协议：

```go
// 并发检测SNMP和SSH
protocols := []string{"SNMP", "SSH"}
results := make(chan ProtocolResult, len(protocols))
```

### 6.3 超时控制

每个检测阶段都有超时控制：

```yaml
# connectivity_check.yaml
timeout: 10s

# device_info_collect.yaml
timeout: 30s
```

## 七、错误处理

### 7.1 检测失败处理

1. **连接失败**: 尝试下一个协议
2. **规则不匹配**: 使用默认配置
3. **配置不存在**: 使用分类默认配置

### 7.2 日志记录

记录检测过程的详细信息：

```go
logger.Info("Device detection started",
    zap.String("ip", req.IP),
    zap.Strings("protocols", availableProtocols),
)

logger.Info("Device detected",
    zap.String("manufacturer", result.Manufacturer),
    zap.String("platform", result.Platform),
    zap.Float64("confidence", result.Confidence),
)
```

## 八、测试

### 8.1 单元测试

```go
func TestDetectCiscoIOS(t *testing.T) {
    detector := NewDeviceDetector(testTemplatePath)
    
    result, err := detector.Detect(&DetectionRequest{
        IP: "192.168.1.1",
        SNMPCommunity: "public",
    })
    
    assert.NoError(t, err)
    assert.Equal(t, "Cisco", result.Manufacturer)
    assert.Equal(t, "IOS", result.Platform)
    assert.Greater(t, result.Confidence, 0.8)
}
```

### 8.2 集成测试

测试完整的检测流程，包括：
- 连接检测
- 信息采集
- 规则匹配
- 配置匹配

## 九、监控和告警

### 9.1 监控指标

- 检测成功率
- 检测平均耗时
- 各厂商/平台检测分布
- 检测失败原因统计

### 9.2 告警规则

- 检测成功率 < 80%
- 检测平均耗时 > 30s
- 特定设备类型检测失败率 > 50%

## 十、常见问题

### Q1: 检测失败怎么办？

A: 系统会尝试多种策略：
1. 尝试其他协议（SNMP → SSH → TELNET）
2. 使用默认配置（按分类）
3. 记录错误日志，便于后续分析

### Q2: 如何提高检测准确性？

A: 
1. 优化正则表达式，使其更精确
2. 添加更多识别特征
3. 提高必需条件的置信度
4. 调整规则优先级

### Q3: 检测耗时多久？

A: 
- SNMP检测: ~5秒
- SSH检测: ~10-15秒
- 完整检测: ~20-30秒（包含所有协议尝试）

### Q4: 如何禁用自动检测？

A: 在请求中明确指定manufacturer和platform，系统会跳过自动检测。

## 十一、后续优化方向

1. **机器学习**: 使用ML模型提高检测准确性
2. **指纹库**: 建立设备指纹库，支持更精确的识别
3. **分布式检测**: 支持分布式检测，提高并发能力
4. **检测历史**: 记录检测历史，支持设备类型变更追踪

