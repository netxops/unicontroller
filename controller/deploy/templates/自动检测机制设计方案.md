# 厂商和平台自动检测机制设计方案

## 一、设计目标

1. **自动识别设备类型**：无需手动指定manufacturer和platform
2. **多协议支持**：支持SNMP、SSH、TELNET等多种检测方式
3. **渐进式检测**：从通用到具体，逐步缩小范围
4. **高可靠性**：检测失败时有回退机制
5. **可扩展性**：易于添加新的检测规则

## 二、检测流程设计

### 2.1 整体流程

```
设备发现请求
    ↓
阶段1: 基础连接检测
    ├─ SNMP可达性检测
    ├─ SSH可达性检测
    └─ TELNET可达性检测
    ↓
阶段2: 设备信息采集
    ├─ SNMP sysDescr采集
    ├─ SSH版本命令采集
    └─ 服务器OS信息采集
    ↓
阶段3: 设备识别
    ├─ 规则匹配（厂商识别）
    ├─ 规则匹配（平台识别）
    └─ 规则匹配（版本识别）
    ↓
阶段4: 配置匹配
    ├─ 查找匹配的配置模板
    ├─ 加载设备配置
    └─ 验证配置有效性
    ↓
阶段5: 确认检测
    └─ 执行一次完整采集验证
```

### 2.2 检测阶段详细设计

#### 阶段1: 基础连接检测

**目标**: 确定设备支持的协议

```yaml
# detect/connectivity_check.yaml
name: connectivityCheck
protocols:
  - name: SNMP
    check:
      type: SNMP
      oid: 1.3.6.1.2.1.1.1.0  # sysDescr
      timeout: 5s
  - name: SSH
    check:
      type: TCP
      port: 22
      timeout: 5s
  - name: TELNET
    check:
      type: TCP
      port: 23
      timeout: 5s
```

#### 阶段2: 设备信息采集

**目标**: 采集设备标识信息

```yaml
# detect/device_info_collect.yaml
name: deviceInfoCollect
strategies:
  # 策略1: SNMP优先（网络设备）
  - name: snmpFirst
    priority: 1
    conditions:
      - protocol: SNMP
        available: true
    collect:
      - type: Collect
        method: SNMP
        target: 1.3.6.1.2.1.1.1.0  # sysDescr
        output: sysDescr
      - type: Collect
        method: SNMP
        target: 1.3.6.1.2.1.1.5.0  # sysName
        output: sysName
  
  # 策略2: SSH优先（服务器或网络设备）
  - name: sshFirst
    priority: 2
    conditions:
      - protocol: SSH
        available: true
    collect:
      - type: Collect
        method: SSH
        target: "uname -a"  # Linux服务器
        output: unameInfo
      - type: Collect
        method: SSH
        target: "cat /etc/os-release"  # Linux发行版信息
        output: osRelease
      - type: Collect
        method: SSH
        target: "show version"  # 网络设备
        output: versionInfo
```

#### 阶段3: 设备识别规则

**目标**: 从采集的信息中识别厂商和平台

```yaml
# detect/rules/manufacturer_rules.yaml
rules:
  # Cisco识别规则
  - name: cisco
    manufacturer: Cisco
    priority: 10
    patterns:
      - source: sysDescr
        regex: "(?i)cisco"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)cisco.*ios"
        confidence: 0.95
      - source: versionInfo
        regex: "(?i)cisco.*nexus"
        confidence: 0.95
  
  # Huawei识别规则
  - name: huawei
    manufacturer: Huawei
    priority: 10
    patterns:
      - source: sysDescr
        regex: "(?i)huawei"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)huawei|vrp"
        confidence: 0.95
  
  # Dell识别规则
  - name: dell
    manufacturer: Dell
    priority: 10
    patterns:
      - source: sysDescr
        regex: "(?i)dell"
        confidence: 0.9
      - source: osRelease
        regex: "(?i)NAME=.*Ubuntu|NAME=.*CentOS"
        confidence: 0.8
  
  # H3C识别规则
  - name: h3c
    manufacturer: H3C
    priority: 10
    patterns:
      - source: sysDescr
        regex: "(?i)h3c|comware"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)comware|secpath"
        confidence: 0.95

# detect/rules/platform_rules.yaml
rules:
  # Cisco IOS
  - name: cisco_ios
    manufacturer: Cisco
    platform: IOS
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)cisco.*ios.*software"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)ios.*version|cisco.*ios"
        confidence: 0.95
  
  # Cisco Nexus
  - name: cisco_nexus
    manufacturer: Cisco
    platform: Nexus
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)nexus"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)nx-os|nexus"
        confidence: 0.95
  
  # Huawei VRP
  - name: huawei_vrp
    manufacturer: Huawei
    platform: VRP
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)vrp"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)vrp.*software"
        confidence: 0.95
  
  # Huawei USG
  - name: huawei_usg
    manufacturer: Huawei
    platform: USG
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)usg"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)usg.*firewall"
        confidence: 0.95
  
  # H3C Comware
  - name: h3c_comware
    manufacturer: H3C
    platform: Comware
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)comware"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)comware.*software"
        confidence: 0.95
  
  # H3C SecPath
  - name: h3c_secpath
    manufacturer: H3C
    platform: SecPath
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)secpath"
        confidence: 0.9
      - source: versionInfo
        regex: "(?i)secpath.*firewall"
        confidence: 0.95
  
  # Dell Ubuntu
  - name: dell_ubuntu
    manufacturer: Dell
    platform: Ubuntu
    priority: 20
    patterns:
      - source: osRelease
        regex: "(?i)NAME=.*Ubuntu"
        confidence: 0.95
      - source: unameInfo
        regex: "(?i)ubuntu"
        confidence: 0.8
  
  # Dell CentOS
  - name: dell_centos
    manufacturer: Dell
    platform: Centos
    priority: 20
    patterns:
      - source: osRelease
        regex: "(?i)NAME=.*CentOS|NAME=.*\"CentOS"
        confidence: 0.95
      - source: unameInfo
        regex: "(?i)centos"
        confidence: 0.8
  
  # 通用Linux服务器
  - name: server_linux
    manufacturer: server
    platform: base_linux
    priority: 15
    patterns:
      - source: osRelease
        regex: "(?i)NAME=.*"
        confidence: 0.7
      - source: unameInfo
        regex: "(?i)linux"
        confidence: 0.6
```

## 三、检测规则库设计

### 3.1 规则结构

```yaml
# detect/rules/base_rule.yaml
rule:
  name: string              # 规则名称
  manufacturer: string      # 厂商名称（可选）
  platform: string          # 平台名称（可选）
  catalog: string           # 设备分类：NETWORK/SERVER/SWITCH/FIREWALL
  priority: int             # 优先级（数字越大优先级越高）
  
  # 匹配条件
  conditions:
    - source: string        # 数据源：sysDescr, versionInfo, osRelease等
      regex: string         # 正则表达式
      confidence: float     # 置信度 0.0-1.0
      required: bool        # 是否必需
  
  # 版本提取规则（可选）
  versionExtract:
    source: string
    regex: string
    groups: []string         # 捕获组名称
  
  # 平台细化规则（可选）
  platformRefine:
    - condition: string     # 条件表达式
      platform: string      # 细化后的平台名称
```

### 3.2 规则匹配算法

```go
type DetectionRule struct {
    Name         string
    Manufacturer string
    Platform     string
    Catalog      string
    Priority     int
    Patterns     []Pattern
    VersionExtract *VersionExtractRule
}

type Pattern struct {
    Source     string
    Regex      string
    Confidence float64
    Required   bool
}

func MatchRules(collectedData map[string]string, rules []DetectionRule) (*DetectionResult, error) {
    var candidates []DetectionRule
    
    // 1. 初步匹配：找出所有可能匹配的规则
    for _, rule := range rules {
        score := 0.0
        matched := true
        
        for _, pattern := range rule.Patterns {
            data, exists := collectedData[pattern.Source]
            if !exists && pattern.Required {
                matched = false
                break
            }
            
            if exists {
                matched, _ := regexp.MatchString(pattern.Regex, data)
                if matched {
                    score += pattern.Confidence
                } else if pattern.Required {
                    matched = false
                    break
                }
            }
        }
        
        if matched && score > 0 {
            rule.Score = score
            candidates = append(candidates, rule)
        }
    }
    
    // 2. 按优先级和置信度排序
    sort.Slice(candidates, func(i, j int) bool {
        if candidates[i].Priority != candidates[j].Priority {
            return candidates[i].Priority > candidates[j].Priority
        }
        return candidates[i].Score > candidates[j].Score
    })
    
    // 3. 返回最佳匹配
    if len(candidates) > 0 {
        best := candidates[0]
        return &DetectionResult{
            Manufacturer: best.Manufacturer,
            Platform:     best.Platform,
            Catalog:      best.Catalog,
            Confidence:   best.Score,
            Version:      extractVersion(collectedData, best.VersionExtract),
        }, nil
    }
    
    return nil, errors.New("no matching rule found")
}
```

## 四、配置匹配机制

### 4.1 配置查找策略

```yaml
# detect/config_matcher.yaml
name: configMatcher
strategies:
  # 策略1: 精确匹配
  - name: exactMatch
    priority: 1
    match:
      manufacturer: exact
      platform: exact
      version: exact
  
  # 策略2: 平台匹配（忽略版本）
  - name: platformMatch
    priority: 2
    match:
      manufacturer: exact
      platform: exact
      version: any
  
  # 策略3: 厂商匹配（使用默认平台）
  - name: manufacturerMatch
    priority: 3
    match:
      manufacturer: exact
      platform: default
      version: any
  
  # 策略4: 分类匹配（使用通用配置）
  - name: catalogMatch
    priority: 4
    match:
      catalog: exact
      manufacturer: default
      platform: default
```

### 4.2 配置路径解析

```
检测结果: manufacturer=Cisco, platform=IOS, version=15.0
    ↓
查找路径:
    1. cisco/ios/v15/config.yaml (精确匹配)
    2. cisco/ios/base/config.yaml (平台匹配)
    3. cisco/default/config.yaml (厂商匹配)
    4. network/default/config.yaml (分类匹配)
```

## 五、检测配置结构

### 5.1 检测配置目录结构

```
deploy/templates/
├── detect/                    # 检测配置目录
│   ├── connectivity_check.yaml    # 连接检测配置
│   ├── device_info_collect.yaml   # 设备信息采集配置
│   ├── rules/                     # 检测规则库
│   │   ├── manufacturer_rules.yaml # 厂商识别规则
│   │   ├── platform_rules.yaml   # 平台识别规则
│   │   ├── version_rules.yaml     # 版本识别规则
│   │   └── catalog_rules.yaml     # 分类识别规则
│   └── config_matcher.yaml        # 配置匹配策略
```

### 5.2 检测配置示例

```yaml
# detect/device_info_collect.yaml
name: deviceInfoCollect
timeout: 30s
retries: 2

strategies:
  # SNMP策略（网络设备）
  - name: snmpStrategy
    priority: 1
    conditions:
      - protocol: SNMP
        available: true
    collect:
      - name: sysDescr
        type: Collect
        method: SNMP
        target: 1.3.6.1.2.1.1.1.0
        timeout: 5s
        output: sysDescr
      
      - name: sysName
        type: Collect
        method: SNMP
        target: 1.3.6.1.2.1.1.5.0
        timeout: 5s
        output: sysName
      
      - name: sysVersion
        type: Collect
        method: SNMP
        target: 1.3.6.1.2.1.1.1.0
        timeout: 5s
        output: sysVersion
  
  # SSH策略（服务器或网络设备）
  - name: sshStrategy
    priority: 2
    conditions:
      - protocol: SSH
        available: true
    collect:
      # Linux服务器检测
      - name: osRelease
        type: Collect
        method: SSH
        target: "cat /etc/os-release"
        timeout: 10s
        output: osRelease
      
      - name: unameInfo
        type: Collect
        method: SSH
        target: "uname -a"
        timeout: 10s
        output: unameInfo
      
      # 网络设备版本检测
      - name: versionInfo
        type: Collect
        method: SSH
        target: "show version"
        timeout: 15s
        output: versionInfo
        fallback:
          - target: "display version"
          - target: "show ver"
```

## 六、实现方案

### 6.1 检测服务接口

```go
// pkg/detector/detector.go
package detector

type DeviceDetector struct {
    rules          []DetectionRule
    configMatcher  *ConfigMatcher
    pipelineService *PipelineService
}

type DetectionRequest struct {
    IP          string
    SNMPCommunity string
    SSHCredentials *SSHCredentials
    TelnetCredentials *TelnetCredentials
}

type DetectionResult struct {
    Manufacturer string
    Platform     string
    Version      string
    Catalog      string
    Confidence   float64
    DeviceConfig *structs.DeviceConfig
    Errors       []error
}

func (d *DeviceDetector) Detect(req *DetectionRequest) (*DetectionResult, error) {
    // 1. 连接检测
    protocols, err := d.checkConnectivity(req)
    if err != nil {
        return nil, err
    }
    
    // 2. 信息采集
    collectedData, err := d.collectDeviceInfo(req, protocols)
    if err != nil {
        return nil, err
    }
    
    // 3. 规则匹配
    detectionResult, err := d.matchRules(collectedData)
    if err != nil {
        return nil, err
    }
    
    // 4. 配置匹配
    deviceConfig, err := d.configMatcher.Match(
        detectionResult.Manufacturer,
        detectionResult.Platform,
        detectionResult.Version,
    )
    if err != nil {
        return nil, err
    }
    
    detectionResult.DeviceConfig = deviceConfig
    
    // 5. 验证检测结果（可选）
    if err := d.verifyDetection(req, detectionResult); err != nil {
        detectionResult.Errors = append(detectionResult.Errors, err)
    }
    
    return detectionResult, nil
}
```

### 6.2 规则加载器

```go
// pkg/detector/rule_loader.go
package detector

func LoadRules(templatePath string) ([]DetectionRule, error) {
    rules := []DetectionRule{}
    
    // 加载厂商规则
    manufacturerRules, err := loadYAML(filepath.Join(templatePath, "detect/rules/manufacturer_rules.yaml"))
    if err != nil {
        return nil, err
    }
    
    // 加载平台规则
    platformRules, err := loadYAML(filepath.Join(templatePath, "detect/rules/platform_rules.yaml"))
    if err != nil {
        return nil, err
    }
    
    // 合并规则
    rules = append(rules, manufacturerRules...)
    rules = append(rules, platformRules...)
    
    // 按优先级排序
    sort.Slice(rules, func(i, j int) bool {
        return rules[i].Priority > rules[j].Priority
    })
    
    return rules, nil
}
```

### 6.3 配置匹配器

```go
// pkg/detector/config_matcher.go
package detector

type ConfigMatcher struct {
    templatePath string
    pipelineService *PipelineService
}

func (cm *ConfigMatcher) Match(manufacturer, platform, version string) (*structs.DeviceConfig, error) {
    // 尝试精确匹配
    config, err := cm.pipelineService.GetDeviceConfig(manufacturer, platform, version, nil)
    if err == nil && config != nil {
        return config, nil
    }
    
    // 尝试平台匹配（忽略版本）
    config, err = cm.pipelineService.GetDeviceConfig(manufacturer, platform, "", nil)
    if err == nil && config != nil {
        return config, nil
    }
    
    // 尝试厂商匹配（使用默认平台）
    defaultPlatform := cm.getDefaultPlatform(manufacturer)
    if defaultPlatform != "" {
        config, err = cm.pipelineService.GetDeviceConfig(manufacturer, defaultPlatform, "", nil)
        if err == nil && config != nil {
            return config, nil
        }
    }
    
    // 使用分类匹配
    catalog := cm.getCatalog(manufacturer, platform)
    return cm.getCatalogConfig(catalog)
}
```

## 七、集成到现有系统

### 7.1 API集成

```go
// pkg/controller/api/api.go
func (ap *ControllerAPI) DetectDevice(w http.ResponseWriter, r *http.Request) {
    var request struct {
        IP            string
        SNMPCommunity string
        SSHCredentials *structs.SSHCredentials
    }
    
    if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // 创建检测器
    detector := detector.NewDeviceDetector(ap.controller.ConfigManager.Config.BaseConfig.PipelineTemplates)
    
    // 执行检测
    result, err := detector.Detect(&detector.DetectionRequest{
        IP:            request.IP,
        SNMPCommunity: request.SNMPCommunity,
        SSHCredentials: request.SSHCredentials,
    })
    
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    json.NewEncoder(w).Encode(result)
}
```

### 7.2 自动检测流程集成

```go
// 在创建设备时，如果manufacturer/platform为空，自动检测
func (ap *ControllerAPI) createDevice(request *DeviceRequest) (*netdevice.BaseNetworkDevice, error) {
    // 如果manufacturer或platform为空，执行自动检测
    if request.RemoteInfo.Manufacturer == "" || request.RemoteInfo.Platform == "" {
        detector := detector.NewDeviceDetector(ap.controller.ConfigManager.Config.BaseConfig.PipelineTemplates)
        
        detectionResult, err := detector.Detect(&detector.DetectionRequest{
            IP:            request.RemoteInfo.Ip,
            SNMPCommunity: request.RemoteInfo.Community[0],
            SSHCredentials: &structs.SSHCredentials{
                Username: request.RemoteInfo.Username,
                Password: request.RemoteInfo.Password,
            },
        })
        
        if err == nil {
            // 使用检测结果更新请求
            request.RemoteInfo.Manufacturer = detectionResult.Manufacturer
            request.RemoteInfo.Platform = detectionResult.Platform
            if detectionResult.Version != "" {
                request.RemoteInfo.Meta.Version = detectionResult.Version
            }
            
            // 如果检测到了配置，直接使用
            if detectionResult.DeviceConfig != nil {
                modeConfig, hubConfig := ap.extractConfigsFromDeviceConfig(detectionResult.DeviceConfig)
                return netdevice.NewBaseNetworkDevice(baseInfo, modeConfig, hubConfig, logger)
            }
        }
    }
    
    // 继续原有的设备创建流程
    // ...
}
```

## 八、检测规则示例

### 8.1 Cisco IOS检测规则

```yaml
# detect/rules/cisco_ios.yaml
rules:
  - name: cisco_ios_snmp
    manufacturer: Cisco
    platform: IOS
    catalog: NETWORK
    priority: 20
    patterns:
      - source: sysDescr
        regex: "(?i)cisco.*ios.*software.*version"
        confidence: 0.95
        required: true
      - source: sysDescr
        regex: "(?i)cisco.*systems"
        confidence: 0.8
    versionExtract:
      source: sysDescr
      regex: "Version ([\\d\\.\\(\\w\\)]+)"
      groups: ["version"]
  
  - name: cisco_ios_ssh
    manufacturer: Cisco
    platform: IOS
    catalog: NETWORK
    priority: 20
    patterns:
      - source: versionInfo
        regex: "(?i)cisco.*ios.*software"
        confidence: 0.95
        required: true
      - source: versionInfo
        regex: "(?i)version.*\\d+"
        confidence: 0.8
    versionExtract:
      source: versionInfo
      regex: "Version ([\\d\\.\\(\\w\\)]+)"
      groups: ["version"]
```

### 8.2 Dell Ubuntu检测规则

```yaml
# detect/rules/dell_ubuntu.yaml
rules:
  - name: dell_ubuntu_osrelease
    manufacturer: Dell
    platform: Ubuntu
    catalog: SERVER
    priority: 20
    patterns:
      - source: osRelease
        regex: "(?i)NAME=.*Ubuntu"
        confidence: 0.95
        required: true
      - source: osRelease
        regex: "(?i)ID=ubuntu"
        confidence: 0.9
    versionExtract:
      source: osRelease
      regex: "VERSION_ID=\"([\\d\\.]+)\""
      groups: ["version"]
  
  - name: dell_ubuntu_uname
    manufacturer: Dell
    platform: Ubuntu
    catalog: SERVER
    priority: 15
    patterns:
      - source: unameInfo
        regex: "(?i)ubuntu"
        confidence: 0.8
        required: true
      - source: unameInfo
        regex: "(?i)linux"
        confidence: 0.6
```

## 九、检测结果缓存

### 9.1 缓存策略

```go
type DetectionCache struct {
    cache map[string]*CachedDetectionResult
    ttl   time.Duration
}

type CachedDetectionResult struct {
    Result      *DetectionResult
    DetectedAt  time.Time
    ExpiresAt   time.Time
}

func (dc *DetectionCache) Get(ip string) (*DetectionResult, bool) {
    cached, exists := dc.cache[ip]
    if !exists {
        return nil, false
    }
    
    if time.Now().After(cached.ExpiresAt) {
        delete(dc.cache, ip)
        return nil, false
    }
    
    return cached.Result, true
}

func (dc *DetectionCache) Set(ip string, result *DetectionResult) {
    dc.cache[ip] = &CachedDetectionResult{
        Result:     result,
        DetectedAt: time.Now(),
        ExpiresAt:  time.Now().Add(dc.ttl),
    }
}
```

## 十、总结

### 10.1 优势

1. **自动化**: 无需手动指定设备类型
2. **可靠性**: 多协议、多规则、渐进式检测
3. **可扩展**: 易于添加新的检测规则
4. **性能**: 支持结果缓存，避免重复检测
5. **兼容性**: 与现有系统无缝集成

### 10.2 实施步骤

1. **阶段1**: 创建检测规则库
2. **阶段2**: 实现检测服务
3. **阶段3**: 集成到现有API
4. **阶段4**: 添加检测结果缓存
5. **阶段5**: 完善错误处理和日志

### 10.3 注意事项

1. **检测准确性**: 规则需要不断优化和调整
2. **性能考虑**: 检测过程可能较慢，需要超时控制
3. **错误处理**: 检测失败时需要有明确的回退策略
4. **规则维护**: 新增设备类型需要添加相应规则

